---
title: OpenClaw Cron 작업 모범 사례 - 세션 비대화 및 메모리 문제 방지
description: OpenClaw cron 작업을 올바르게 구성하고, 세션 누적을 방지하며, 메인 세션과 격리 실행 중 최적의 선택을 하는 방법 학습
slug: /cron-job-best-practices
tags: cron, 자동화, 스케줄링, 성능, 모범사례
publishedAt: 2026-02-14
status: published
visibility: public
featuredImageUrl: /images/features/cron-job-best-practices.webp
---

# OpenClaw Cron 작업 모범 사례

Cron 작업은 OpenClaw에서 반복 작업을 자동화하는 데 필수적입니다 — 일일 브리핑부터 정기 모니터링까지. 그러나 부적절한 구성은 세션 비대화, 메모리 문제 및 비용 폭주로 이어질 수 있습니다. 이 가이드에서는 신뢰할 수 있고 효율적인 cron 작업을 설정하기 위한 모범 사례를 다룹니다.

## 세션 누적 문제

OpenClaw cron 작업에서 가장 흔한 문제 중 하나는 **세션 컨텍스트 누적**입니다. 다음과 같이 발생합니다:

1. 매시간 실행되는 격리된 cron 작업 생성
2. 각 실행마다 세션에 더 많은 컨텍스트 추가
3. 며칠/몇 주에 걸쳐 세션이 무한정 성장
4. 결국 컨텍스트가 한계에 도달하여 작업 실패 또는 비용 증가

이것은 OpenClaw 저장소에서 추적된 알려진 문제로, 격리된 cron 세션이 무기한으로 컨텍스트를 누적했습니다.

## Cron 실행 모드 이해

OpenClaw cron 작업은 두 가지 모드로 실행할 수 있으며, 올바른 모드를 선택하는 것이 중요합니다:

### 메인 세션 작업

메인 세션 작업은 기본 세션에 시스템 이벤트를 주입합니다:

```bash
openclaw cron add \
  --name "받은편지함 확인" \
  --cron "0 * * * *" \
  --session main \
  --system-event "긴급 이메일 확인" \
  --wake now
```

**특징:**
- 메인 세션 컨텍스트에서 실행
- 전체 대화 기록에 액세스 가능
- 일반 상호작용과 컨텍스트 공유
- 대화 인식이 필요한 작업에 적합

**사용 시기:**
- 최근 대화를 알아야 하는 작업
- 이전 컨텍스트 기반 후속 알림
- 워크플로우에 자연스럽게 통합되는 가벼운 확인

### 격리 세션 작업

격리된 작업은 전용 `cron:<jobId>` 세션에서 실행됩니다:

```bash
openclaw cron add \
  --name "일일 보고서" \
  --cron "0 9 * * *" \
  --tz "Asia/Seoul" \
  --session isolated \
  --message "일일 상태 보고서 생성" \
  --announce
```

**특징:**
- 각 실행이 새로운 세션으로 시작 (이전 컨텍스트 이월 없음)
- 다른 모델/사고 설정 사용 가능
- 출력이 채널에 직접 발표
- 기록이 메인 세션을 어지럽히지 않음

**사용 시기:**
- 이전 컨텍스트가 필요 없는 독립 작업
- 다른 모델 요구사항이 있는 무거운 분석
- 메인 세션 기록을 스팸하는 빈번한 작업
- 깨끗한 상태 실행이 필요한 작업

## 모범 사례 #1: Announce가 포함된 격리 작업 사용

대부분의 반복 자동화에는 announce 전달이 포함된 격리 작업을 사용합니다:

```bash
openclaw cron add \
  --name "아침 브리핑" \
  --cron "0 7 * * *" \
  --tz "Asia/Seoul" \
  --session isolated \
  --message "요약: 날씨, 캘린더, 중요 이메일." \
  --announce \
  --channel telegram \
  --to "123456789"
```

이를 통해 보장됩니다:
- 각 실행마다 새로운 컨텍스트 (누적 없음)
- 결과가 채팅에 직접 전달
- 메인 세션이 깨끗하게 유지
- 예측 가능한 리소스 사용

## 모범 사례 #2: 일회성 작업 자동 삭제

알림 및 일회성 작업에는 `--at`과 `--delete-after-run`을 사용합니다:

```bash
openclaw cron add \
  --name "회의 알림" \
  --at "20m" \
  --session main \
  --system-event "스탠드업 회의가 10분 후에 시작됩니다!" \
  --wake now \
  --delete-after-run
```

일회성 작업(`--at`)은 기본적으로 성공 후 삭제됩니다. 작업 기록을 유지해야 하는 경우에만 `--keep-after-run`을 사용하세요.

## 모범 사례 #3: Heartbeat에서 확인 일괄 처리

정기 확인을 위해 여러 cron 작업을 만드는 대신 heartbeat 메커니즘을 사용합니다:

**HEARTBEAT.md:**
```markdown
# Heartbeat 체크리스트

- 긴급 메시지 받은편지함 확인
- 다음 2시간 캘린더 이벤트 확인
- 프로젝트 상태 확인
- 8시간 이상 조용하면 가벼운 체크인
```

**이것이 더 나은 이유:**
- 한 번의 에이전트 턴으로 여러 확인 처리
- API 호출 및 비용 감소
- 컨텍스트 인식 우선순위 지정
- 관련 작업의 자연스러운 일괄 처리

## 모범 사례 #4: 올바른 스케줄 유형 선택

OpenClaw는 세 가지 스케줄 유형을 지원합니다:

### 일회성 (`--at`)

특정 미래 시간용:

```bash
# 상대 시간
openclaw cron add --at "2h" --name "..." ...

# 절대 시간 (ISO 8601, 시간대 없으면 UTC)
openclaw cron add --at "2026-02-15T14:00:00Z" --name "..." ...
```

### 간격 (`--every`)

고정 간격용:

```bash
# 4시간마다
openclaw cron add --every "4h" --name "..." ...
```

### Cron 표현식 (`--cron`)

복잡한 스케줄용:

```bash
# 매주 월요일 오전 9시
openclaw cron add --cron "0 9 * * 1" --tz "Asia/Seoul" --name "..." ...

# 평일 매일 오전 8:30
openclaw cron add --cron "30 8 * * 1-5" --tz "Asia/Seoul" --name "..." ...
```

**중요:** 시간대 혼란을 피하기 위해 cron 표현식에는 항상 `--tz`를 지정하세요.

## 모범 사례 #5: 모델 및 사고 재정의

무거운 분석에는 격리 작업에서 모델을 재정의합니다:

```bash
openclaw cron add \
  --name "주간 심층 분석" \
  --cron "0 6 * * 0" \
  --session isolated \
  --message "프로젝트 진행, 차단 요소, 권장 사항 심층 분석." \
  --model opus \
  --thinking high \
  --announce
```

**가이드라인:**
- 일상 작업에는 저렴한 모델 (sonnet) 사용
- 복잡한 분석에는 비싼 모델 (opus) 예약
- 사고 수준: `off`, `minimal`, `low`, `medium`, `high`, `xhigh`

## 모범 사례 #6: 적절한 전달 구성

격리 작업에는 전달을 명시적으로 구성합니다:

```bash
# 특정 채널에 발표
openclaw cron add \
  --session isolated \
  --message "..." \
  --announce \
  --channel whatsapp \
  --to "+821012345678"

# Telegram 토픽/스레드 지원
openclaw cron add \
  --session isolated \
  --message "..." \
  --announce \
  --channel telegram \
  --to "-1001234567890:topic:123"

# 전달 없음 (내부만)
openclaw cron add \
  --session isolated \
  --message "..." \
  --no-deliver
```

**전달 모드:**
- `--announce`: 대상 채널에 요약 전달 (격리의 기본값)
- `--no-deliver`: 출력을 내부에 유지, 발표 없음

## 일반적인 문제 해결

### 작업이 실행되지 않음

1. **cron 활성화 확인:**
   ```bash
   openclaw cron status
   ```

2. **Gateway 실행 확인:**
   ```bash
   openclaw gateway status
   ```

3. **시간대 설정 확인:**
   ```bash
   openclaw cron list --json | jq '.[] | {name, schedule}'
   ```

### 세션 비대화 (레거시 작업)

컨텍스트가 누적된 오래된 작업이 있는 경우:

1. 모든 작업 나열:
   ```bash
   openclaw cron list
   ```

2. 문제 작업 제거:
   ```bash
   openclaw cron remove <job-id>
   ```

3. 격리 모드로 재생성:
   ```bash
   openclaw cron add --session isolated ...
   ```

### 전달 실패

발표가 채팅에 도달하지 않는 경우:

1. 전달 구성 확인:
   ```bash
   openclaw cron list --json | jq '.[] | {name, delivery}'
   ```

2. 채널/대상 형식 확인:
   - Telegram: 채팅 ID 또는 `chat_id:topic:thread_id`
   - WhatsApp: 국가 코드가 포함된 전화번호
   - Discord/Slack: `channel:ID` 또는 `user:ID`

3. 전달 문제로 인한 작업 실패 방지를 위해 `--best-effort` 사용:
   ```bash
   openclaw cron edit <job-id> --best-effort
   ```

## 빠른 참조: Cron vs Heartbeat

| 사용 사례 | 권장 | 이유 |
|----------|------|------|
| 30분마다 받은편지함 확인 | Heartbeat | 다른 확인과 일괄 처리 |
| 매일 오전 9시 정각 보고서 | Cron (격리) | 정확한 타이밍 필요 |
| "20분 후 알려줘" | Cron (메인, `--at`) | 정밀한 일회성 |
| 주간 심층 분석 | Cron (격리) | 다른 모델, 깨끗한 상태 |
| 백그라운드 모니터링 | Heartbeat | 기존 주기에 편승 |

## 요약

1. **격리 작업 사용** — 반복 자동화에서 세션 비대화 방지
2. **heartbeat 사용** — 여러 정기 확인 일괄 처리
3. **항상 시간대 지정** — cron 표현식에
4. **적절히 모델 재정의** — 작업 복잡도에 따라
5. **전달을 명시적으로 구성** — 격리 작업에
6. **`--delete-after-run` 사용** — 일회성 알림에
7. **작업 상태 모니터링** — `openclaw cron list`와 `openclaw cron runs`로

이러한 사례를 따르면 cron 작업이 컨텍스트를 누적하거나 성능 문제를 일으키지 않고 안정적으로 실행됩니다.
