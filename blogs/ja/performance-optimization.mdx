---
title: OpenClaw パフォーマンス最適化ガイド - 遅延とメモリリークの解決
description: OpenClaw の一般的なパフォーマンス問題を特定して修正するための包括的なガイド。トークン最適化、メモリ管理、セッションプルーニング戦略を含む
slug: /performance-optimization
publishedAt: 2026-02-14
status: published
visibility: public
featuredImageUrl: /images/features/performance_optimization.webp
---

# OpenClaw パフォーマンス最適化ガイド：遅延とメモリリークの解決

OpenClaw を数日から数週間にわたってスムーズに実行するには、リソース管理の仕組みを理解する必要があります。このガイドでは、一般的なパフォーマンスのボトルネックと、AI アシスタントを高速で効率的に保つための実用的なソリューションを紹介します。

## トークン使用量とコストの理解

AI モデルとのすべてのやり取りでトークンが消費され、パフォーマンスとコストの両方に直接影響します。OpenClaw は以下の全体でトークン使用量を包括的に追跡します：

- システムプロンプト（ツール、スキル、ワークスペースファイル）
- 会話履歴
- ツール呼び出しと結果
- 添付ファイルとトランスクリプト
- キャッシュ操作

### トークン消費量の監視

リアルタイムで使用量を追跡するには、以下のコマンドを使用します：

**現在のセッションステータスを確認：**
```
/status
```
モデル、コンテキスト使用量、推定コストを表示します。

**レスポンスごとの使用量フッターを有効化：**
```
/usage full
```
すべてのレスポンスの後に詳細なトークンメトリクスを追加します。

**コスト概要を表示：**
```
/usage cost
```
セッションログから累積コストを表示します。

### トークン最適化戦略

**1. ツール出力の制限**

大きなツール結果（ファイル読み取り、Web フェッチ）は大量のトークンを消費します。設定で出力制限を設定します：

```json
{
  "tools": {
    "read": {
      "maxChars": 50000
    }
  }
}
```

**2. セッションプルーニングの使用**

OpenClaw は、モデルにコンテキストを送信する前に、古いツール結果を自動的にトリミングできます。cache-TTL プルーニングを有効化：

```json
{
  "agents": {
    "defaults": {
      "contextPruning": {
        "mode": "cache-ttl",
        "ttl": "5m",
        "keepLastAssistants": 3
      }
    }
  }
}
```

**仕組み：**
- 最後の 3 つのアシスタントメッセージとそのツール結果のみを保持
- 古いツール出力をトリムまたはクリア
- キャッシュ TTL が期限切れになった場合のみ実行
- 画像を含むツール結果を保護

**3. プロンプトキャッシングの活用**

Anthropic モデルの場合、プロンプトキャッシングにより繰り返しコンテキストのコストを大幅に削減できます：

```json
{
  "agents": {
    "defaults": {
      "model": {
        "primary": "anthropic/claude-opus-4-5"
      },
      "models": {
        "anthropic/claude-opus-4-5": {
          "params": {
            "cacheRetention": "long"
          }
        }
      }
    }
  }
}
```

**キャッシュ最適化のヒント：**
- キャッシュ TTL は通常 5 分（Anthropic）
- 1 時間 TTL のキャッシュを保持するにはハートビート（`every: "55m"`）を使用
- キャッシュ読み取りは入力トークンの 10 分の 1 のコスト
- キャッシュ期限切れ前のプルーニングでキャッシュ書き込みコストを削減

**4. 長いセッションの圧縮**

会話が長くなりすぎた場合、OpenClaw は古いメッセージを要約できます：

```
/compact 重要な決定と未解決の質問に焦点を当てる
```

コンテキスト制限に近づくと自動圧縮がトリガーされます。閾値を設定：

```json
{
  "agents": {
    "defaults": {
      "compaction": {
        "autoCompact": true,
        "targetRatio": 0.8,
        "minMessagesBeforeCompact": 10
      }
    }
  }
}
```

## セッションとメモリ管理

### セッションライフサイクルのベストプラクティス

**古いセッションをリセット：**
```
/reset
```
ディスク上の会話履歴を保持しながらコンテキストをクリアします。

**新規開始：**
```
/new
```
クリーンな状態で新しいセッションを作成します。

**セッションの健全性を確認：**
```
/context detail
```
コンテキストウィンドウへの各ファイルの寄与を表示します。

### メモリファイルの最適化

OpenClaw は各セッション開始時にワークスペースファイル（`AGENTS.md`、`SOUL.md`、`TOOLS.md` など）を読み込みます。これらを軽量に保ちます：

**ブートストラップファイルサイズの制限：**
```json
{
  "agents": {
    "defaults": {
      "bootstrapMaxChars": 20000
    }
  }
}
```

**ベストプラクティス：**
- `AGENTS.md` はワークフロールールに焦点を当てる
- 詳細な参照は別ファイルに保存し、必要に応じて読み込む
- 古い `memory/YYYY-MM-DD.md` ファイルを定期的にアーカイブ
- 古いコンテキストを削除して `MEMORY.md` を圧縮

## 一般的なパフォーマンスの落とし穴

### 1. **無制限のツール出力**

**問題：** 大きなログファイルの読み取りや Web ページ全体の取得がコンテキストを膨らませる。

**解決策：**
```json
{
  "tools": {
    "read": {
      "maxChars": 10000
    },
    "exec": {
      "outputMaxChars": 5000
    }
  }
}
```

### 2. **忘れられたハートビート**

**問題：** 毎分のハートビートチェックが大量のトークンを消費。

**解決策：** 必要に応じて 30 分〜1 時間に調整：
```json
{
  "agents": {
    "defaults": {
      "heartbeat": {
        "every": "30m"
      }
    }
  }
}
```

### 3. **古いキャッシュ書き込み**

**問題：** セッションがキャッシュ TTL を超えてアイドル状態になり、次のリクエストで完全なプロンプトを再書き込み。

**解決策：** cache-TTL プルーニングを有効にしてキャッシュウィンドウをリセット：
```json
{
  "agents": {
    "defaults": {
      "contextPruning": {
        "mode": "cache-ttl",
        "ttl": "5m"
      }
    }
  }
}
```

### 4. **ツール結果内の画像添付**

**問題：** 画像は大量のトークンを消費。

**解決策：**
- セッションプルーニングは画像を含むツール結果をスキップ
- コンテキストがいっぱいになったら手動で `/reset`
- 画像が蓄積する前に `/compact` を使用して要約

### 5. **診断のオーバーロード**

**問題：** 高サンプルレートですべての診断を OpenTelemetry にエクスポート。

**解決策：** サンプリングを使用し、ログレベルでフィルタリング：
```json
{
  "diagnostics": {
    "otel": {
      "sampleRate": 0.1,
      "logs": false
    }
  }
}
```

## 本番環境の推奨設定

コストとパフォーマンスのバランスが取れた設定：

```json
{
  "agents": {
    "defaults": {
      "model": {
        "primary": "anthropic/claude-sonnet-4-5"
      },
      "models": {
        "anthropic/claude-sonnet-4-5": {
          "params": {
            "cacheRetention": "long"
          }
        }
      },
      "contextPruning": {
        "mode": "cache-ttl",
        "ttl": "5m",
        "keepLastAssistants": 3,
        "softTrimRatio": 0.3
      },
      "compaction": {
        "autoCompact": true,
        "targetRatio": 0.8,
        "minMessagesBeforeCompact": 10
      },
      "heartbeat": {
        "every": "30m"
      },
      "bootstrapMaxChars": 20000
    }
  },
  "logging": {
    "level": "info",
    "consoleLevel": "info",
    "redactSensitive": "tools"
  },
  "tools": {
    "read": {
      "maxChars": 50000
    },
    "exec": {
      "outputMaxChars": 10000
    }
  }
}
```

## トラブルシューティングチェックリスト

遅延や高コストが発生した場合：

1. **トークン使用量を確認：** `/status` と `/usage full`
2. **コンテキストサイズを確認：** `/context detail`
3. **スタックしたセッションを探す：** `openclaw status`
4. **ログを確認：** `openclaw logs --follow`
5. **キュー深度を確認：** メトリクスで `openclaw.queue.depth` を確認
6. **キャッシュ動作を検証：** ログで頻繁な `cacheWrite` を確認
7. **ツール出力を監査：** `--raw-stream` で実際のレスポンスを確認
8. **圧縮をテスト：** `/compact` してレスポンス時間を比較
9. **コストを監視：** `/usage cost` で高コストパターンを発見
10. **必要に応じてリセット：** 古いセッションには `/reset`

---

**プロのヒント：** 設定の問題を早期に発見するために、定期的に `openclaw doctor` を実行してください。パフォーマンス最適化は反復的なプロセスです — 監視、調整、テスト！
