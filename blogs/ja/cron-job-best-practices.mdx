---
title: OpenClaw Cronジョブのベストプラクティス - セッション肥大化とメモリ問題を回避する
description: OpenClaw cronジョブを正しく設定し、セッション蓄積を防ぎ、メインセッションと分離実行を適切に選択する方法を学ぶ
slug: /cron-job-best-practices
tags: cron, 自動化, スケジューリング, パフォーマンス, ベストプラクティス
publishedAt: 2026-02-14
status: published
visibility: public
featuredImageUrl: /images/features/cron-job-best-practices.webp
---

# OpenClaw Cronジョブのベストプラクティス

Cronジョブは、OpenClawで繰り返しタスクを自動化するために不可欠です — 日次ブリーフィングから定期的な監視まで。しかし、不適切な設定はセッションの肥大化、メモリの問題、コストの暴走につながる可能性があります。このガイドでは、信頼性が高く効率的なcronジョブを設定するためのベストプラクティスを説明します。

## セッション蓄積問題

OpenClaw cronジョブで最も一般的な問題の1つは、**セッションコンテキストの蓄積**です。以下のように発生します：

1. 毎時実行される分離cronジョブを作成
2. 各実行でセッションにコンテキストが追加される
3. 数日/数週間でセッションが無制限に成長
4. 最終的にコンテキストが制限に達し、ジョブが失敗するか高コストになる

これはOpenClawリポジトリで追跡されていた既知の問題で、分離cronセッションが無期限にコンテキストを蓄積していました。

## Cron実行モードの理解

OpenClaw cronジョブは2つのモードで実行でき、正しいモードを選択することが重要です：

### メインセッションジョブ

メインセッションジョブは、プライマリセッションにシステムイベントを注入します：

```bash
openclaw cron add \
  --name "受信トレイ確認" \
  --cron "0 * * * *" \
  --session main \
  --system-event "緊急メールの受信トレイを確認" \
  --wake now
```

**特徴：**
- メインセッションコンテキストで実行
- 完全な会話履歴にアクセス可能
- 通常のやり取りとコンテキストを共有
- 会話認識が必要なタスクに最適

**使用場面：**
- 最近の会話を知る必要があるタスク
- 以前のコンテキストに基づくフォローアップリマインダー
- ワークフローに自然に統合される軽いチェック

### 分離セッションジョブ

分離ジョブは専用の `cron:<jobId>` セッションで実行されます：

```bash
openclaw cron add \
  --name "日次レポート" \
  --cron "0 9 * * *" \
  --tz "Asia/Tokyo" \
  --session isolated \
  --message "日次ステータスレポートを生成" \
  --announce
```

**特徴：**
- 各実行は新鮮なセッションで開始（以前のコンテキスト引き継ぎなし）
- 異なるモデル/思考設定を使用可能
- 出力はチャンネルに直接アナウンス
- 履歴がメインセッションを乱さない

**使用場面：**
- 以前のコンテキストを必要としないスタンドアロンタスク
- 異なるモデル要件を持つ重い分析
- メインセッション履歴をスパムする頻繁なジョブ
- クリーンな状態での実行が必要なタスク

## ベストプラクティス #1: アナウンス付き分離ジョブを使用

ほとんどの繰り返し自動化には、アナウンス配信付きの分離ジョブを使用します：

```bash
openclaw cron add \
  --name "朝のブリーフィング" \
  --cron "0 7 * * *" \
  --tz "Asia/Tokyo" \
  --session isolated \
  --message "要約：天気、カレンダー、重要なメール。" \
  --announce \
  --channel telegram \
  --to "123456789"
```

これにより以下が保証されます：
- 各実行で新鮮なコンテキスト（蓄積なし）
- 結果がチャットに直接配信
- メインセッションがクリーンに保たれる
- 予測可能なリソース使用

## ベストプラクティス #2: ワンショットジョブは自動削除

リマインダーや一回限りのタスクには、`--at` と `--delete-after-run` を使用：

```bash
openclaw cron add \
  --name "ミーティングリマインダー" \
  --at "20m" \
  --session main \
  --system-event "スタンドアップミーティングが10分後に始まります！" \
  --wake now \
  --delete-after-run
```

ワンショットジョブ（`--at`）はデフォルトで成功後に削除されます。ジョブ記録を保持する必要がある場合のみ `--keep-after-run` を使用してください。

## ベストプラクティス #3: ハートビートでチェックをバッチ処理

定期的なチェックのために複数のcronジョブを作成する代わりに、ハートビートメカニズムを使用します：

**HEARTBEAT.md:**
```markdown
# ハートビートチェックリスト

- 緊急メッセージの受信トレイを確認
- 次の2時間のカレンダーイベントを確認
- プロジェクトステータスを確認
- 8時間以上静かな場合は軽いチェックイン
```

**これが優れている理由：**
- 1回のエージェントターンで複数のチェックを処理
- API呼び出しとコストを削減
- コンテキスト認識の優先順位付け
- 関連タスクの自然なバッチ処理

## ベストプラクティス #4: 適切なスケジュールタイプを選択

OpenClawは3つのスケジュールタイプをサポートしています：

### ワンショット（`--at`）

特定の将来の時間用：

```bash
# 相対時間
openclaw cron add --at "2h" --name "..." ...

# 絶対時間（ISO 8601、タイムゾーンなしはUTC）
openclaw cron add --at "2026-02-15T14:00:00Z" --name "..." ...
```

### インターバル（`--every`）

固定間隔用：

```bash
# 4時間ごと
openclaw cron add --every "4h" --name "..." ...
```

### Cron式（`--cron`）

複雑なスケジュール用：

```bash
# 毎週月曜日午前9時
openclaw cron add --cron "0 9 * * 1" --tz "Asia/Tokyo" --name "..." ...

# 平日毎日午前8:30
openclaw cron add --cron "30 8 * * 1-5" --tz "Asia/Tokyo" --name "..." ...
```

**重要：** タイムゾーンの混乱を避けるため、cron式には常に `--tz` を指定してください。

## ベストプラクティス #5: モデルと思考のオーバーライド

重い分析には、分離ジョブでモデルをオーバーライドします：

```bash
openclaw cron add \
  --name "週次詳細分析" \
  --cron "0 6 * * 0" \
  --session isolated \
  --message "プロジェクトの進捗、ブロッカー、推奨事項の詳細分析。" \
  --model opus \
  --thinking high \
  --announce
```

**ガイドライン：**
- ルーチンタスクには安価なモデル（sonnet）を使用
- 複雑な分析には高価なモデル（opus）を予約
- 思考レベル：`off`、`minimal`、`low`、`medium`、`high`、`xhigh`

## ベストプラクティス #6: 適切な配信設定

分離ジョブには、配信を明示的に設定します：

```bash
# 特定のチャンネルにアナウンス
openclaw cron add \
  --session isolated \
  --message "..." \
  --announce \
  --channel whatsapp \
  --to "+815012345678"

# Telegramのトピック/スレッドサポート
openclaw cron add \
  --session isolated \
  --message "..." \
  --announce \
  --channel telegram \
  --to "-1001234567890:topic:123"

# 配信なし（内部のみ）
openclaw cron add \
  --session isolated \
  --message "..." \
  --no-deliver
```

**配信モード：**
- `--announce`：ターゲットチャンネルにサマリーを配信（分離のデフォルト）
- `--no-deliver`：出力を内部に保持、アナウンスなし

## 一般的な問題のトラブルシューティング

### ジョブが実行されない

1. **cronが有効か確認：**
   ```bash
   openclaw cron status
   ```

2. **Gatewayが実行中か確認：**
   ```bash
   openclaw gateway status
   ```

3. **タイムゾーン設定を確認：**
   ```bash
   openclaw cron list --json | jq '.[] | {name, schedule}'
   ```

### セッション肥大化（レガシージョブ）

コンテキストが蓄積された古いジョブがある場合：

1. すべてのジョブをリスト：
   ```bash
   openclaw cron list
   ```

2. 問題のあるジョブを削除：
   ```bash
   openclaw cron remove <job-id>
   ```

3. 分離モードで再作成：
   ```bash
   openclaw cron add --session isolated ...
   ```

### 配信失敗

アナウンスがチャットに届かない場合：

1. 配信設定を確認：
   ```bash
   openclaw cron list --json | jq '.[] | {name, delivery}'
   ```

2. チャンネル/ターゲット形式を確認：
   - Telegram：チャットIDまたは `chat_id:topic:thread_id`
   - WhatsApp：国コード付き電話番号
   - Discord/Slack：`channel:ID` または `user:ID`

3. 配信問題でジョブ失敗を防ぐために `--best-effort` を使用：
   ```bash
   openclaw cron edit <job-id> --best-effort
   ```

## クイックリファレンス：Cron vs ハートビート

| ユースケース | 推奨 | 理由 |
|-------------|------|------|
| 30分ごとに受信トレイ確認 | ハートビート | 他のチェックとバッチ処理 |
| 毎日9時きっかりにレポート | Cron（分離） | 正確なタイミングが必要 |
| 「20分後にリマインド」 | Cron（メイン、`--at`） | 精密なワンショット |
| 週次詳細分析 | Cron（分離） | 異なるモデル、クリーンな状態 |
| バックグラウンド監視 | ハートビート | 既存サイクルに便乗 |

## まとめ

1. **分離ジョブを使用** して繰り返し自動化でセッション肥大化を回避
2. **ハートビートを使用** して複数の定期チェックをバッチ処理
3. **常にタイムゾーンを指定** してcron式に
4. **適切にモデルをオーバーライド** してタスクの複雑さに基づいて
5. **配信を明示的に設定** して分離ジョブに
6. **`--delete-after-run` を使用** してワンショットリマインダーに
7. **ジョブの健全性を監視** して `openclaw cron list` と `openclaw cron runs` で

これらのプラクティスに従えば、cronジョブはコンテキストを蓄積したりパフォーマンスの問題を引き起こすことなく、確実に実行されます。
