---
title: "형식 검증 (보안 모델)"
summary: "TLA+/TLC를 사용한 OpenClaw의 기계 검증 가능한 보안 모델"
---

# 형식 검증 (Formal Verification) (보안 모델)

이 페이지는 OpenClaw의 형식 보안 모델을 추적합니다 (현재 TLA+/TLC; 필요에 따라 추가 예정).

**참고:** 일부 오래된 링크는 이전 프로젝트 이름을 참조할 수 있습니다.

**목표 (북극성):** 명시적 가정 하에서 OpenClaw가 의도된 보안 정책(인가, 세션 격리, tool 게이팅, 잘못된 구성 안전성)을 시행한다는 기계 검증 가능한 논증을 제공합니다.

## 이것은 무엇인가 (현재)

실행 가능한, 공격자 주도 보안 회귀 suite:

- 각 주장은 유한 상태 공간에 대한 실행 가능한 모델 검사를 가지고 있습니다.
- 많은 주장은 현실적인 버그 클래스에 대한 반례 trace를 생성하는 페어링된 부정 모델을 가지고 있습니다.

## 이것이 아닌 것 (아직)

"OpenClaw는 모든 측면에서 안전하다"는 증명이나 전체 TypeScript 구현이 올바르다는 증명이 아닙니다.

## 모델 위치

모델은 별도의 저장소에서 유지 관리됩니다: [vignesh07/openclaw-formal-models](https://github.com/vignesh07/openclaw-formal-models).

## 중요한 주의사항

- 이것들은 모델이지 전체 TypeScript 구현이 아닙니다. 모델과 코드 간에 차이가 있을 수 있습니다.
- 결과는 TLC가 탐색한 상태 공간에 의해 제한됩니다. "녹색"은 모델링된 가정과 경계를 넘어선 보안을 의미하지 않습니다.
- 일부 주장은 명시적 환경 가정(예: 올바른 배포, 올바른 구성 입력)에 의존합니다.

## 결과 재현

현재 결과는 모델 저장소를 로컬로 클론하고 TLC를 실행하여 재현됩니다(아래 참조). 향후 반복에서는 다음을 제공할 수 있습니다:

- 공개 아티팩트(반례 trace, 실행 로그)가 있는 CI 실행 모델
- 작고 제한된 검사를 위한 호스팅된 "이 모델 실행" 워크플로우

시작하기:

```bash
git clone https://github.com/vignesh07/openclaw-formal-models
cd openclaw-formal-models

# Java 11+ 필요 (TLC는 JVM에서 실행됨).
# 저장소는 고정된 `tla2tools.jar` (TLA+ tools)를 제공하며 `bin/tlc` + Make 대상을 제공합니다.

make <target>
```

### 게이트웨이 노출 및 오픈 게이트웨이 잘못된 구성

**주장:** 인증 없이 루프백 이상으로 바인딩하면 원격 침해가 가능해지거나 노출이 증가할 수 있습니다. 토큰/비밀번호는 미인증 공격자를 차단합니다(모델 가정에 따름).

- 그린 실행:
  - `make gateway-exposure-v2`
  - `make gateway-exposure-v2-protected`
- 레드 (예상):
  - `make gateway-exposure-v2-negative`

참조: 모델 저장소의 `docs/gateway-exposure-matrix.md`.

### Nodes.run 파이프라인 (최고 위험 기능)

**주장:** `nodes.run`에는 (a) node 명령 허용 목록과 선언된 명령, (b) 구성 시 실시간 승인이 필요합니다. 승인은 재생을 방지하기 위해 토큰화됩니다(모델 내).

- 그린 실행:
  - `make nodes-pipeline`
  - `make approvals-token`
- 레드 (예상):
  - `make nodes-pipeline-negative`
  - `make approvals-token-negative`

### 페어링 저장소 (DM 게이팅)

**주장:** 페어링 요청은 TTL과 대기 중인 요청 상한을 존중합니다.

- 그린 실행:
  - `make pairing`
  - `make pairing-cap`
- 레드 (예상):
  - `make pairing-negative`
  - `make pairing-cap-negative`

### 입력 게이팅 (멘션 + 제어 명령 우회)

**주장:** 멘션이 필요한 그룹 컨텍스트에서, 무단 "제어 명령"은 멘션 게이팅을 우회할 수 없습니다.

- 그린:
  - `make ingress-gating`
- 레드 (예상):
  - `make ingress-gating-negative`

### 라우팅/세션 키 격리

**주장:** 서로 다른 peer로부터의 DM은 명시적으로 연결/구성되지 않는 한 동일한 세션으로 통합되지 않습니다.

- 그린:
  - `make routing-isolation`
- 레드 (예상):
  - `make routing-isolation-negative`

## v1++: 추가 제한된 모델 (동시성, 재시도, trace 정확성)

이것들은 실제 실패 모드(비원자적 업데이트, 재시도, 메시지 팬아웃)에 대한 충실도를 높이는 후속 모델입니다.

### 페어링 저장소 동시성 / 멱등성

**주장:** 페어링 저장소는 인터리빙 하에서도 MaxPending과 멱등성을 시행해야 합니다(즉, "확인 후 쓰기"는 원자적/잠금되어야 하며, 새로 고침은 중복을 생성해서는 안 됩니다).

의미:

- 동시 요청 하에서 채널의 MaxPending을 초과할 수 없습니다.
- 동일한 (채널, 발신자)에 대한 반복 요청/새로 고침은 중복 라이브 대기 행을 생성해서는 안 됩니다.

- 그린 실행:
  - `make pairing-race` (원자적/잠금된 cap 확인)
  - `make pairing-idempotency`
  - `make pairing-refresh`
  - `make pairing-refresh-race`
- 레드 (예상):
  - `make pairing-race-negative` (비원자적 begin/commit cap 경쟁)
  - `make pairing-idempotency-negative`
  - `make pairing-refresh-negative`
  - `make pairing-refresh-race-negative`

### 입력 trace 상관관계 / 멱등성

**주장:** 수집은 팬아웃 전체에서 trace 상관관계를 보존하고 프로바이더 재시도 하에서 멱등적이어야 합니다.

의미:

- 하나의 외부 이벤트가 여러 내부 메시지가 될 때, 모든 부분은 동일한 trace/이벤트 identity를 유지합니다.
- 재시도는 이중 처리를 초래하지 않습니다.
- 프로바이더 이벤트 ID가 누락된 경우, 중복 제거는 안전한 키(예: trace ID)로 폴백하여 별개 이벤트를 삭제하지 않습니다.

- 그린:
  - `make ingress-trace`
  - `make ingress-trace2`
  - `make ingress-idempotency`
  - `make ingress-dedupe-fallback`
- 레드 (예상):
  - `make ingress-trace-negative`
  - `make ingress-trace2-negative`
  - `make ingress-idempotency-negative`
  - `make ingress-dedupe-fallback-negative`

### 라우팅 dmScope 우선순위 + identityLinks

**주장:** 라우팅은 기본적으로 DM 세션을 격리된 상태로 유지해야 하며, 명시적으로 구성된 경우에만 세션을 통합해야 합니다(채널 우선순위 + identity 링크).

의미:

- 채널별 dmScope 재정의는 전역 기본값보다 우선해야 합니다.
- identityLinks는 명시적으로 연결된 그룹 내에서만 통합해야 하며, 관련 없는 peer 간에는 통합하지 않아야 합니다.

- 그린:
  - `make routing-precedence`
  - `make routing-identitylinks`
- 레드 (예상):
  - `make routing-precedence-negative`
  - `make routing-identitylinks-negative`
