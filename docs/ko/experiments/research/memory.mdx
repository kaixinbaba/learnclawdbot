---
title: "작업 공간 메모리 연구"
summary: "Markdown을 정규 소스로, 구조화된 회상을 위한 파생 인덱스를 가진 오프라인 우선 메모리 아키텍처"
---

# 작업 공간 메모리 v2 (오프라인): 연구 노트

**대상:** Clawd 스타일 작업 공간(`agents.defaults.workspace`, 기본값 `~/.openclaw/workspace`). 여기서 "메모리"는 하루 하나의 Markdown 파일(`memory/YYYY-MM-DD.md`)과 소수의 안정적인 파일(예: `memory.md`, `SOUL.md`)로 저장됩니다.

이 문서는 Markdown을 정규적이고 검토 가능한 진실의 원천으로 유지하면서 파생 인덱스를 통해 구조화된 회상(검색, 엔티티 요약, 신뢰도 업데이트)을 추가하는 오프라인 우선 메모리 아키텍처를 제안합니다.

## 왜 변경해야 하는가?

현재 설정(하루 하나의 파일)은 다음에 뛰어납니다:

- "추가 전용" 저널링
- 사람의 편집
- git 기반 내구성 + 감사 가능성
- 낮은 마찰 캡처("그냥 적어라")

약점:

- 높은 회상 검색("X에 대해 무엇을 결정했는가?", "마지막으로 Y를 시도했을 때?")
- 엔티티 중심 답변("Alice / The Castle / warelay에 대해 알려줘")을 많은 파일을 다시 읽지 않고
- 의견/선호도 안정성(그리고 그것이 변경될 때의 증거)
- 시간 제약("2025년 11월 동안 무엇이 사실이었는가?") 및 충돌 해결

## 설계 목표

- **오프라인:** 네트워크 없이 작동; 노트북/Castle에서 실행 가능; 클라우드 의존성 없음
- **설명 가능:** 검색된 항목은 귀속 가능(파일 + 위치)하며 추론과 분리 가능해야 함
- **낮은 의식:** 일일 로깅은 Markdown 유지, 무거운 스키마 작업 없음
- **증분:** v1은 FTS만으로 유용함; 시맨틱/벡터 및 그래프는 선택적 업그레이드
- **에이전트 친화적:** "토큰 예산 내 회상"을 쉽게 만듦(작은 사실 묶음 반환)

## 북극성 모델 (Hindsight × Letta)

융합할 두 부분:

### Letta/MemGPT 스타일 제어 루프

- 항상 컨텍스트에 작은 "core" 유지(페르소나 + 주요 사용자 사실)
- 그 외 모든 것은 컨텍스트 밖에 있으며 도구를 통해 검색
- 메모리 쓰기는 명시적 도구 호출(append/replace/insert), 지속되고 다음 턴에 재주입

### Hindsight 스타일 메모리 기반

- 관찰된 것 vs 믿어지는 것 vs 요약된 것을 분리
- retain/recall/reflect 지원
- 증거와 함께 진화할 수 있는 신뢰도를 가진 의견
- 엔티티 인식 검색 + 시간 쿼리(전체 지식 그래프 없이도)

## 제안된 아키텍처 (Markdown 진실의 원천 + 파생 인덱스)

### 정규 저장소 (git 친화적)

`~/.openclaw/workspace`를 정규적이고 사람이 읽을 수 있는 메모리로 유지합니다.

권장 작업 공간 레이아웃:

```
~/.openclaw/workspace/
  memory.md                # 작음: 내구성 있는 사실 + 선호도 (core-ish)
  memory/
    YYYY-MM-DD.md          # 일일 로그 (추가; 서사적)
  bank/                    # "유형화된" 메모리 페이지 (안정적, 검토 가능)
    world.md               # 세계에 대한 객관적 사실
    experience.md          # 에이전트가 한 일 (1인칭)
    opinions.md            # 주관적 선호도/판단 + 신뢰도 + 증거 포인터
    entities/
      Peter.md
      The-Castle.md
      warelay.md
      ...
```

참고:

- 일일 로그는 일일 로그로 유지. JSON으로 전환할 필요 없음
- `bank/` 파일은 큐레이션되고 리플렉션 작업에 의해 생성되며 여전히 수동으로 편집 가능
- `memory.md`는 "small + core-ish" 유지: 모든 세션에서 Clawd가 보기를 원하는 것

### 파생 저장소 (기계 회상)

작업 공간 아래에 파생 인덱스 추가(반드시 git 추적되지 않음):

```
~/.openclaw/workspace/.memory/index.sqlite
```

지원:

- 사실 + 엔티티 링크 + 의견 메타데이터를 위한 SQLite 스키마
- 어휘 회상을 위한 SQLite FTS5(빠르고 작고 오프라인)
- 시맨틱 회상을 위한 선택적 임베딩 테이블(여전히 오프라인)

인덱스는 항상 Markdown에서 재구축 가능.

## Retain / Recall / Reflect (운영 루프)

### Retain: 일일 로그를 "사실"로 정규화

여기서 중요한 Hindsight의 핵심 통찰: 서사적이고 자기 완결적인 사실을 저장하고, 작은 스니펫이 아님.

`memory/YYYY-MM-DD.md`의 실용적 규칙:

- 하루가 끝날 때(또는 도중에), 다음과 같은 2-5개의 글머리 기호가 있는 `## Retain` 섹션 추가:
  - 서사적(교차 턴 컨텍스트 보존)
  - 자기 완결적(나중에 독립적으로 이해됨)
  - 유형 + 엔티티 언급으로 태그

예제:

```markdown
## Retain
- W @Peter: 현재 마라케시(2025년 11월 27일~12월 1일)에 Andy의 생일을 위해 있음.
- B @warelay: connection.update 핸들러를 try/catch로 감싸서 Baileys WS 충돌 수정(memory/2025-11-27.md 참조).
- O(c=0.95) @Peter: WhatsApp에서 간결한 답변(<1500자)을 선호; 긴 콘텐츠는 파일로.
```

최소 파싱:

- 유형 접두사: `W`(세계), `B`(경험/전기), `O`(의견), `S`(관찰/요약; 일반적으로 생성됨)
- 엔티티: `@Peter`, `@warelay` 등(slug는 `bank/entities/*.md`에 매핑)
- 의견 신뢰도: `O(c=0.0..1.0)` 선택 사항

작성자가 생각하지 않기를 원하는 경우: 리플렉트 작업이 로그의 나머지 부분에서 이러한 글머리 기호를 추론할 수 있지만 명시적인 `## Retain` 섹션을 갖는 것이 가장 쉬운 "품질 레버"입니다.

### Recall: 파생 인덱스에 대한 쿼리

회상은 다음을 지원해야 합니다:

- **어휘:** "정확한 용어/이름/명령 찾기"(FTS5)
- **엔티티:** "X에 대해 알려줘"(엔티티 페이지 + 엔티티 링크된 사실)
- **시간:** "11월 27일경 무슨 일이 있었는가" / "지난 주 이후"
- **의견:** "Peter는 무엇을 선호하는가?"(신뢰도 + 증거 포함)

반환 형식은 에이전트 친화적이어야 하며 출처를 인용해야 합니다:

- kind(`world`|`experience`|`opinion`|`observation`)
- timestamp(소스 날짜 또는 존재하는 경우 추출된 시간 범위)
- entities(`["Peter","warelay"]`)
- content(서사적 사실)
- source(`memory/2025-11-27.md#L12` 등)

### Reflect: 안정적인 페이지 생성 + 신념 업데이트

리플렉션은 예약된 작업(매일 또는 heartbeat ultrathink)으로:

- 최근 사실에서 `bank/entities/*.md` 업데이트(엔티티 요약)
- 강화/모순에 기반하여 `bank/opinions.md` 신뢰도 업데이트
- 선택적으로 `memory.md`("core-ish" 내구성 있는 사실)에 대한 편집 제안

의견 진화(간단하고 설명 가능):

- 각 의견에는 다음이 있음:
  - 진술
  - 신뢰도 `c ∈ [0,1]`
  - `last_updated`
  - 증거 링크(지지 + 모순되는 사실 ID)

- 새로운 사실이 도착할 때:
  - 엔티티 중복 + 유사성으로 후보 의견 찾기(FTS 먼저, 나중에 임베딩)
  - 작은 델타로 신뢰도 업데이트; 큰 점프는 강한 모순 + 반복된 증거 필요

## CLI 통합: 독립형 vs 깊은 통합

권장 사항: OpenClaw에 깊이 통합하되 분리 가능한 코어 라이브러리 유지.

### 왜 OpenClaw에 통합하는가?

- OpenClaw는 이미 다음을 알고 있음:
  - 작업 공간 경로(`agents.defaults.workspace`)
  - 세션 모델 + 하트비트
  - 로깅 + 문제 해결 패턴

- 에이전트 자체가 도구를 호출하기를 원함:
  - `openclaw memory recall "…" --k 25 --since 30d`
  - `openclaw memory reflect --since 7d`

### 왜 여전히 라이브러리를 분리하는가?

- gateway/runtime 없이 메모리 로직을 테스트 가능하게 유지
- 다른 컨텍스트에서 재사용(로컬 스크립트, 미래의 데스크톱 앱 등)

형태: 메모리 도구는 작은 CLI + 라이브러리 레이어가 되도록 의도되지만 이것은 탐색적입니다.

## "S-Collide" / SuCo: 언제 사용할 것인가 (연구)

"S-Collide"가 SuCo(Subspace Collision)를 가리키는 경우: 이는 서브스페이스에서 학습된/구조화된 충돌을 사용하여 강력한 회상/지연 시간 트레이드오프를 목표로 하는 ANN 검색 접근 방식입니다(논문: arXiv 2411.14754, 2024).

`~/.openclaw/workspace`에 대한 실용적인 견해:

- SuCo로 시작하지 마세요
- SQLite FTS + (선택적) 간단한 임베딩으로 시작; 대부분의 UX 승리를 즉시 얻을 것
- 다음 경우에만 SuCo/HNSW/ScaNN 클래스 솔루션 고려:
  - 코퍼스가 큼(수만/수십만 청크)
  - 무차별 대입 임베딩 검색이 너무 느려짐
  - 회상 품질이 어휘 검색으로 의미 있게 병목됨

오프라인 친화적 대안(복잡성 증가 순서):

1. SQLite FTS5 + 메타데이터 필터(ML 제로)
2. 임베딩 + 무차별 대입(청크 수가 적으면 놀랍게 잘 작동)
3. HNSW 인덱스(일반적, 견고; 라이브러리 바인딩 필요)
4. SuCo(연구 등급; 임베드할 수 있는 견고한 구현이 있으면 매력적)

미해결 질문:

- 귀하의 기계(노트북 + 데스크톱)에서 "개인 비서 메모리"를 위한 최상의 오프라인 임베딩 모델은 무엇인가?
- 이미 Ollama가 있는 경우: 로컬 모델로 임베드; 그렇지 않으면 도구 체인에 작은 임베딩 모델 포함

## 가장 작은 유용한 파일럿

최소한이지만 여전히 유용한 버전을 원하는 경우:

- 일일 로그에 `bank/` 엔티티 페이지와 `## Retain` 섹션 추가
- 인용과 함께 회상을 위해 SQLite FTS 사용(경로 + 행 번호)
- 회상 품질 또는 규모가 요구하는 경우에만 임베딩 추가

## 참고 자료

- **Letta / MemGPT 개념:** "코어 메모리 블록" + "보관 메모리" + 도구 기반 자체 편집 메모리
- **Hindsight 기술 보고서:** "retain / recall / reflect", 4-네트워크 메모리, 서사적 사실 추출, 의견 신뢰도 진화
- **SuCo:** arXiv 2411.14754(2024): "Subspace Collision" 근사 최근접 이웃 검색
