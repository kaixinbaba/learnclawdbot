---
summary: "Agent 런타임 (임베디드 p-mono), workspace 계약 및 session bootstrap"
read_when:
  - agent 런타임, workspace bootstrap 또는 session 동작을 변경하는 경우
---
# Agent Runtime 🤖

OpenClaw는 **p-mono**에서 파생된 단일 임베디드 agent 런타임을 실행합니다.

## Workspace (필수)

OpenClaw는 단일 agent workspace 디렉토리(`agents.defaults.workspace`)를 tool 및 컨텍스트를 위한 agent의 **유일한** 작업 디렉토리(`cwd`)로 사용합니다.

권장: `openclaw setup`을 사용하여 누락된 경우 `~/.openclaw/openclaw.json`을 생성하고 workspace 파일을 초기화하세요.

전체 workspace 레이아웃 + 백업 가이드: [Agent workspace](/concepts/agent-workspace)

`agents.defaults.sandbox`가 활성화된 경우, 비 main session은 
`agents.defaults.sandbox.workspaceRoot` 아래의 session별 workspace로 재정의할 수 있습니다 
([Gateway configuration](/gateway/configuration) 참조).

## Bootstrap 파일 (주입됨)

`agents.defaults.workspace` 내부에서 OpenClaw는 다음 사용자 편집 가능한 파일을 예상합니다:
- `AGENTS.md` — 작동 지침 + "메모리"
- `SOUL.md` — 페르소나, 경계, 톤
- `TOOLS.md` — 사용자 유지 관리 tool 노트 (예: `imsg`, `sag`, 규칙)
- `BOOTSTRAP.md` — 일회성 첫 실행 의식 (완료 후 삭제됨)
- `IDENTITY.md` — agent 이름/분위기/이모지
- `USER.md` — 사용자 프로필 + 선호하는 호칭

새 session의 첫 번째 턴에서 OpenClaw는 이러한 파일의 내용을 agent 컨텍스트에 직접 주입합니다.

빈 파일은 건너뜁니다. 큰 파일은 프롬프트가 간결하게 유지되도록 잘리고 마커로 잘립니다 (전체 내용을 보려면 파일을 읽으세요).

파일이 누락된 경우, OpenClaw는 단일 "누락된 파일" 마커 라인을 주입합니다 (그리고 `openclaw setup`은 안전한 기본 템플릿을 생성합니다).

`BOOTSTRAP.md`는 **완전히 새로운 workspace**에만 생성됩니다 (다른 bootstrap 파일이 없는 경우). 의식을 완료한 후 삭제하면 이후 재시작 시 재생성되지 않아야 합니다.

bootstrap 파일 생성을 완전히 비활성화하려면 (사전 시드된 workspace의 경우), 다음을 설정하세요:

```json5
{ agent: { skipBootstrap: true } }
```

## 내장 tool

핵심 tool(read/exec/edit/write 및 관련 시스템 tool)은 tool policy에 따라 항상 사용 가능합니다. 
`apply_patch`는 선택 사항이며 `tools.exec.applyPatch`에 의해 제어됩니다. 
`TOOLS.md`는 어떤 tool이 존재하는지 제어하지 **않습니다**; 
*사용자*가 원하는 사용 방법에 대한 지침입니다.

## Skill

OpenClaw는 세 위치에서 skill을 로드합니다 (이름 충돌 시 workspace가 우선):
- 번들 (설치와 함께 제공됨)
- 관리형/로컬: `~/.openclaw/skills`
- Workspace: `<workspace>/skills`

Skill은 config/env에 의해 제어될 수 있습니다 ([Gateway configuration](/gateway/configuration)의 `skills` 참조).

## p-mono 통합

OpenClaw는 p-mono 코드베이스의 조각(model/tool)을 재사용하지만 **session 관리, 검색 및 tool 연결은 OpenClaw가 소유합니다**.

- p-coding agent 런타임 없음.
- `~/.pi/agent` 또는 `<workspace>/.pi` 설정은 참조되지 않습니다.

## Session

Session transcript는 다음 위치에 JSONL로 저장됩니다:
- `~/.openclaw/agents/<agentId>/sessions/<SessionId>.jsonl`

Session ID는 안정적이며 OpenClaw가 선택합니다.
레거시 Pi/Tau session 폴더는 **읽지 않습니다**.

## 스트리밍 중 조향

Queue mode가 `steer`인 경우, 인바운드 메시지가 현재 실행에 주입됩니다.
Queue는 **각 tool 호출 후**에 확인됩니다; 큐에 있는 메시지가 있으면 
현재 assistant 메시지의 나머지 tool 호출이 건너뛰어집니다 ("Skipped due to queued user message."로 오류 tool 
결과), 그런 다음 큐에 있는 사용자 메시지가 다음 assistant 응답 전에 주입됩니다.

Queue mode가 `followup` 또는 `collect`인 경우, 인바운드 메시지는 
현재 턴이 끝날 때까지 보류된 다음 큐에 있는 payload로 새 agent 턴이 시작됩니다. 
mode + debounce/cap 동작은 [Queue](/concepts/queue) 참조.

Block 스트리밍은 완료된 assistant block을 완료되는 즉시 전송합니다; 
**기본적으로 꺼져 있습니다** (`agents.defaults.blockStreamingDefault: "off"`).
경계는 `agents.defaults.blockStreamingBreak`를 통해 조정하세요 (`text_end` vs `message_end`; 기본값 text_end).
소프트 block 청킹은 `agents.defaults.blockStreamingChunk`로 제어하세요 (기본값 
800–1200자; 단락 구분 선호, 그 다음 줄바꿈; 문장 마지막).
스트리밍된 청크를 `agents.defaults.blockStreamingCoalesce`로 병합하여 
단일 라인 스팸을 줄이세요 (전송 전 idle 기반 병합). 비 Telegram channel은 
block 응답을 활성화하려면 명시적으로 `*.blockStreaming: true`가 필요합니다.
Verbose tool 요약은 tool 시작 시 발행됩니다 (debounce 없음); Control UI는 
사용 가능한 경우 agent event를 통해 tool 출력을 스트리밍합니다.
자세한 내용: [Streaming + chunking](/concepts/streaming).

## Model ref

config의 model ref(예: `agents.defaults.model` 및 `agents.defaults.models`)는 **첫 번째** `/`로 분할하여 파싱됩니다.

- model을 구성할 때 `provider/model`을 사용하세요.
- model ID 자체에 `/`가 포함된 경우(OpenRouter 스타일), provider 접두사를 포함하세요 (예: `openrouter/moonshotai/kimi-k2`).
- provider를 생략하면 OpenClaw는 입력을 alias 또는 **기본 provider**의 model로 처리합니다 (model ID에 `/`가 없는 경우에만 작동).

## 구성 (최소)

최소한 다음을 설정하세요:
- `agents.defaults.workspace`
- `channels.whatsapp.allowFrom` (강력 권장)

---

*다음: [Group Chats](/concepts/group-messages)* 🦞
