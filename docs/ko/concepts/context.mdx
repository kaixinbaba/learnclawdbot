---
summary: "컨텍스트: model이 보는 것, 빌드 방법 및 검사 방법"
read_when:
  - OpenClaw에서 "컨텍스트"가 무엇을 의미하는지 이해하고 싶은 경우
  - model이 무언가를 "알고 있는" 이유(또는 잊어버린 이유)를 디버깅하는 경우
  - 컨텍스트 오버헤드를 줄이고 싶은 경우 (/context, /status, /compact)
---
# 컨텍스트

"컨텍스트"는 **OpenClaw가 실행을 위해 model에 전송하는 모든 것**입니다. model의 **컨텍스트 윈도우**(token 제한)에 의해 제한됩니다.

초보자 멘탈 모델:
- **시스템 프롬프트** (OpenClaw 빌드): 규칙, tool, skill 목록, 시간/런타임 및 주입된 workspace 파일.
- **대화 기록**: 이 session에 대한 사용자의 메시지 + assistant의 메시지.
- **Tool 호출/결과 + 첨부 파일**: 명령 출력, 파일 읽기, 이미지/오디오 등.

컨텍스트는 "메모리"와 *동일하지 않습니다*: 메모리는 디스크에 저장되고 나중에 다시 로드될 수 있습니다; 컨텍스트는 model의 현재 윈도우 내부에 있는 것입니다.

## 빠른 시작 (컨텍스트 검사)

- `/status` → 빠른 "내 윈도우가 얼마나 차 있나?" 보기 + session 설정.
- `/context list` → 주입된 것 + 대략적인 크기 (파일별 + 총계).
- `/context detail` → 더 깊은 분석: 파일별, tool schema별 크기, skill 항목별 크기 및 시스템 프롬프트 크기.
- `/usage tokens` → 일반 응답에 응답별 사용량 바닥글 추가.
- `/compact` → 이전 기록을 간결한 항목으로 요약하여 윈도우 공간을 확보.

참조: [Slash commands](/tools/slash-commands), [Token use & costs](/token-use), [Compaction](/concepts/compaction).

## 예제 출력

값은 model, provider, tool policy 및 workspace에 있는 내용에 따라 달라집니다.

### `/context list`

```
🧠 Context breakdown
Workspace: <workspaceDir>
Bootstrap max/file: 20,000 chars
Sandbox: mode=non-main sandboxed=false
System prompt (run): 38,412 chars (~9,603 tok) (Project Context 23,901 chars (~5,976 tok))

Injected workspace files:
- AGENTS.md: OK | raw 1,742 chars (~436 tok) | injected 1,742 chars (~436 tok)
- SOUL.md: OK | raw 912 chars (~228 tok) | injected 912 chars (~228 tok)
- TOOLS.md: TRUNCATED | raw 54,210 chars (~13,553 tok) | injected 20,962 chars (~5,241 tok)
- IDENTITY.md: OK | raw 211 chars (~53 tok) | injected 211 chars (~53 tok)
- USER.md: OK | raw 388 chars (~97 tok) | injected 388 chars (~97 tok)
- HEARTBEAT.md: MISSING | raw 0 | injected 0
- BOOTSTRAP.md: OK | raw 0 chars (~0 tok) | injected 0 chars (~0 tok)

Skills list (system prompt text): 2,184 chars (~546 tok) (12 skills)
Tools: read, edit, write, exec, process, browser, message, sessions_send, …
Tool list (system prompt text): 1,032 chars (~258 tok)
Tool schemas (JSON): 31,988 chars (~7,997 tok) (counts toward context; not shown as text)
Tools: (same as above)

Session tokens (cached): 14,250 total / ctx=32,000
```

### `/context detail`

```
🧠 Context breakdown (detailed)
…
Top skills (prompt entry size):
- frontend-design: 412 chars (~103 tok)
- oracle: 401 chars (~101 tok)
… (+10 more skills)

Top tools (schema size):
- browser: 9,812 chars (~2,453 tok)
- exec: 6,240 chars (~1,560 tok)
… (+N more tools)
```

## 컨텍스트 윈도우에 포함되는 것

model이 받는 모든 것이 포함됩니다:
- 시스템 프롬프트 (모든 섹션).
- 대화 기록.
- Tool 호출 + tool 결과.
- 첨부 파일/transcript (이미지/오디오/파일).
- Compaction 요약 및 pruning 아티팩트.
- Provider "래퍼" 또는 숨겨진 헤더 (보이지 않지만 여전히 계산됨).

## OpenClaw가 시스템 프롬프트를 빌드하는 방법

시스템 프롬프트는 **OpenClaw가 소유**하며 각 실행마다 재빌드됩니다. 포함 사항:
- Tool 목록 + 짧은 설명.
- Skill 목록 (메타데이터만; 아래 참조).
- Workspace 위치.
- 시간 (UTC + 구성된 경우 변환된 사용자 시간).
- 런타임 메타데이터 (host/OS/model/thinking).
- **Project Context** 아래에 주입된 workspace bootstrap 파일.

전체 분석: [System Prompt](/concepts/system-prompt).

## 주입된 workspace 파일 (Project Context)

기본적으로 OpenClaw는 고정된 workspace 파일 세트(있는 경우)를 주입합니다:
- `AGENTS.md`
- `SOUL.md`
- `TOOLS.md`
- `IDENTITY.md`
- `USER.md`
- `HEARTBEAT.md`
- `BOOTSTRAP.md` (첫 실행만)

큰 파일은 `agents.defaults.bootstrapMaxChars`(기본값 `20000` 문자)를 사용하여 파일별로 잘립니다. `/context`는 **원시 vs 주입된** 크기와 잘림 발생 여부를 표시합니다.

## Skill: 주입된 것 vs 온디맨드 로드

시스템 프롬프트에는 간결한 **skill 목록**(이름 + 설명 + 위치)이 포함됩니다. 이 목록에는 실제 오버헤드가 있습니다.

Skill 지침은 *기본적으로 포함되지 않습니다*. model은 **필요할 때만** skill의 `SKILL.md`를 `read`할 것으로 예상됩니다.

## Tool: 두 가지 비용이 있습니다

Tool은 두 가지 방식으로 컨텍스트에 영향을 미칩니다:
1) 시스템 프롬프트의 **tool 목록 텍스트** ("Tooling"으로 표시됨).
2) **Tool schema** (JSON). model이 tool을 호출할 수 있도록 전송됩니다. 일반 텍스트로 보이지 않더라도 컨텍스트에 포함됩니다.

`/context detail`은 가장 큰 tool schema를 분석하여 무엇이 지배적인지 볼 수 있습니다.

## 명령, 지시어 및 "인라인 단축키"

Slash 명령은 Gateway가 처리합니다. 몇 가지 다른 동작이 있습니다:
- **독립형 명령**: `/...`만 있는 메시지는 명령으로 실행됩니다.
- **지시어**: `/think`, `/verbose`, `/reasoning`, `/elevated`, `/model`, `/queue`는 model이 메시지를 보기 전에 제거됩니다.
  - 지시어만 있는 메시지는 session 설정을 지속합니다.
  - 일반 메시지의 인라인 지시어는 메시지별 힌트로 작동합니다.
- **인라인 단축키** (allowlist 발신자만): 일반 메시지 내의 특정 `/...` token은 즉시 실행될 수 있으며 (예: "hey /status"), model이 나머지 텍스트를 보기 전에 제거됩니다.

세부 정보: [Slash commands](/tools/slash-commands).

## Session, compaction 및 pruning (지속되는 것)

메시지 간에 지속되는 것은 메커니즘에 따라 다릅니다:
- **일반 기록**은 policy에 의해 compacted/pruned될 때까지 session transcript에 지속됩니다.
- **Compaction**은 요약을 transcript에 지속하고 최근 메시지를 그대로 유지합니다.
- **Pruning**은 실행을 위한 *인메모리* 프롬프트에서 이전 tool 결과를 제거하지만 transcript를 다시 쓰지는 않습니다.

문서: [Session](/concepts/session), [Compaction](/concepts/compaction), [Session pruning](/concepts/session-pruning).

## `/context`가 실제로 보고하는 것

`/context`는 사용 가능한 경우 최신 **실행 빌드** 시스템 프롬프트 보고서를 선호합니다:
- `System prompt (run)` = 마지막 임베디드(tool 가능) 실행에서 캡처되고 session 저장소에 지속됩니다.
- `System prompt (estimate)` = 실행 보고서가 없을 때(또는 보고서를 생성하지 않는 CLI 백엔드를 통해 실행할 때) 즉시 계산됩니다.

어느 쪽이든 크기와 상위 기여자를 보고합니다; 전체 시스템 프롬프트 또는 tool schema를 덤프하지 **않습니다**.
