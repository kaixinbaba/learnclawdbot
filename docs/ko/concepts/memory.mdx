---
summary: "OpenClaw 메모리 작동 방식 (workspace 파일 + 자동 memory flush)"
read_when:
  - 메모리 파일 레이아웃 및 워크플로우가 필요한 경우
  - 자동 사전 compaction memory flush를 조정하고 싶은 경우
---
# Memory

OpenClaw 메모리는 **agent workspace의 일반 Markdown**입니다. 파일이 진실의 원천입니다; model은 디스크에 쓰여진 것만 "기억"합니다.

Memory 검색 tool은 활성 memory plugin에서 제공됩니다 (기본값: `memory-core`). `plugins.slots.memory = "none"`으로 memory plugin을 비활성화합니다.

## Memory 파일 (Markdown)

기본 workspace 레이아웃은 두 메모리 레이어를 사용합니다:

- `memory/YYYY-MM-DD.md`
  - 일일 로그 (추가 전용).
  - session 시작 시 오늘 + 어제를 읽습니다.
- `MEMORY.md` (선택)
  - 큐레이션된 장기 메모리.
  - **main, 비공개 session에서만 로드합니다** (그룹 컨텍스트에서는 절대 안 됨).

이러한 파일은 workspace(`agents.defaults.workspace`, 기본값 `~/.openclaw/workspace`) 아래에 있습니다. 전체 레이아웃은 [Agent workspace](/concepts/agent-workspace) 참조.

## 메모리를 쓸 때

- 결정, 선호도 및 내구성 있는 사실은 `MEMORY.md`로 이동합니다.
- 일상 노트 및 실행 컨텍스트는 `memory/YYYY-MM-DD.md`로 이동합니다.
- 누군가 "이것을 기억하세요"라고 말하면 적어두세요 (RAM에 보관하지 마세요).
- 이 영역은 여전히 진화 중입니다. model에게 메모리를 저장하도록 상기시키는 것이 도움이 됩니다; model은 무엇을 해야 할지 알 것입니다.
- 무언가를 고정하고 싶다면 **bot에게 메모리에 작성하도록 요청하세요**.

## 자동 memory flush (사전 compaction ping)

Session이 **자동 compaction에 가까워지면** OpenClaw는 컨텍스트가 compacted되기 **전에** 내구성 있는 메모리를 작성하도록 model에게 상기시키는 **무음, agentic 턴**을 트리거합니다. 기본 프롬프트는 model이 *응답할 수 있다*고 명시적으로 말하지만, 일반적으로 `NO_REPLY`가 올바른 응답이므로 사용자는 이 턴을 절대 보지 않습니다.

이는 `agents.defaults.compaction.memoryFlush`에 의해 제어됩니다:

```json5
{
  agents: {
    defaults: {
      compaction: {
        reserveTokensFloor: 20000,
        memoryFlush: {
          enabled: true,
          softThresholdTokens: 4000,
          systemPrompt: "Session nearing compaction. Store durable memories now.",
          prompt: "Write any lasting notes to memory/YYYY-MM-DD.md; reply with NO_REPLY if nothing to store."
        }
      }
    }
  }
}
```

자세한 내용 및 vector memory 검색 구성은 영문 원본을 참조하세요 ([Memory](/concepts/memory)).
