---
title: Lobster
summary: "재개 가능한 승인 게이트가 있는 OpenClaw용 타입 지정 워크플로 런타임."
description: OpenClaw용 타입 지정 워크플로 런타임 — 승인 게이트가 있는 구성 가능한 파이프라인.
read_when:
  - 명시적 승인이 있는 결정론적 다단계 워크플로를 원할 때
  - 이전 단계를 다시 실행하지 않고 워크플로를 재개해야 할 때
---

# Lobster

Lobster는 OpenClaw가 명시적 승인 체크포인트와 함께 다단계 도구 시퀀스를 단일 결정론적 작업으로 실행할 수 있게 하는 워크플로 쉘입니다.

## 핵심

어시스턴트가 자신을 관리하는 도구를 구축할 수 있습니다. 워크플로를 요청하면 30분 후에 하나의 호출로 실행되는 CLI와 파이프라인이 생깁니다. Lobster는 누락된 부분입니다: 결정론적 파이프라인, 명시적 승인, 재개 가능한 상태.

## 이유

오늘날 복잡한 워크플로는 많은 왕복 도구 호출이 필요합니다. 각 호출은 토큰 비용이 들고 LLM이 모든 단계를 조율해야 합니다. Lobster는 해당 조율을 타입 지정된 런타임으로 이동합니다:

- **여러 호출 대신 하나의 호출**: OpenClaw는 하나의 Lobster 도구 호출을 실행하고 구조화된 결과를 얻습니다.
- **내장 승인**: 부작용(이메일 보내기, 댓글 게시)은 명시적으로 승인될 때까지 워크플로를 중단합니다.
- **재개 가능**: 중단된 워크플로는 토큰을 반환합니다; 모든 것을 다시 실행하지 않고 승인하고 재개합니다.

## 일반 프로그램 대신 DSL을 사용하는 이유는?

Lobster는 의도적으로 작습니다. 목표는 "새로운 언어"가 아니라 일급 승인 및 재개 토큰이 있는 예측 가능한 AI 친화적 파이프라인 사양입니다.

- **승인/재개가 내장되어 있음**: 일반 프로그램은 사람에게 프롬프트할 수 있지만 해당 런타임을 직접 발명하지 않고는 내구성 있는 토큰으로 *일시 중지 및 재개*할 수 없습니다.
- **결정론 + 감사 가능성**: 파이프라인은 데이터이므로 로그, diff, 재생 및 검토가 쉽습니다.
- **AI를 위한 제한된 표면**: 작은 문법 + JSON 파이핑은 "창의적인" 코드 경로를 줄이고 검증을 현실적으로 만듭니다.
- **내장된 안전 정책**: 타임아웃, 출력 제한, 샌드박스 검사 및 allowlist는 각 스크립트가 아닌 런타임에서 시행됩니다.
- **여전히 프로그래밍 가능**: 각 단계는 모든 CLI 또는 스크립트를 호출할 수 있습니다. JS/TS를 원하면 코드에서 `.lobster` 파일을 생성하세요.

## 작동 방식

OpenClaw는 **도구 모드**에서 로컬 `lobster` CLI를 시작하고 stdout에서 JSON 엔벨로프를 파싱합니다.
파이프라인이 승인을 위해 일시 중지되면 도구는 나중에 계속할 수 있도록 `resumeToken`을 반환합니다.

## 패턴: 소형 CLI + JSON 파이프 + 승인

JSON을 사용하는 작은 명령을 빌드한 다음 단일 Lobster 호출로 연결합니다. (아래 예제 명령 이름 — 자신의 것으로 교체)

```bash
inbox list --json
inbox categorize --json
inbox apply --json
```

```json
{
  "action": "run",
  "pipeline": "exec --json --shell 'inbox list --json' | exec --stdin json --shell 'inbox categorize --json' | exec --stdin json --shell 'inbox apply --json' | approve --preview-from-stdin --limit 5 --prompt 'Apply changes?'",
  "timeoutMs": 30000
}
```

파이프라인이 승인을 요청하면 토큰으로 재개하세요:

```json
{
  "action": "resume",
  "token": "<resumeToken>",
  "approve": true
}
```

AI가 워크플로를 트리거합니다; Lobster가 단계를 실행합니다. 승인 게이트는 부작용을 명시적이고 감사 가능하게 유지합니다.

예제: 입력 항목을 도구 호출에 매핑:

```bash
gog.gmail.search --query 'newer_than:1d' \
  | openclaw.invoke --tool message --action send --each --item-key message --args-json '{"provider":"telegram","to":"..."}'
```

## JSON 전용 LLM 단계 (llm-task)

**구조화된 LLM 단계**가 필요한 워크플로의 경우 선택적
`llm-task` 플러그인 도구를 활성화하고 Lobster에서 호출하세요. 이렇게 하면 워크플로가
결정론적으로 유지되면서도 모델로 분류/요약/초안 작성을 할 수 있습니다.

도구 활성화:

```json
{
  "plugins": {
    "entries": {
      "llm-task": { "enabled": true }
    }
  },
  "agents": {
    "list": [
      {
        "id": "main",
        "tools": { "allow": ["llm-task"] }
      }
    ]
  }
}
```

파이프라인에서 사용:

```lobster
openclaw.invoke --tool llm-task --action json --args-json '{
  "prompt": "Given the input email, return intent and draft.",
  "input": { "subject": "Hello", "body": "Can you help?" },
  "schema": {
    "type": "object",
    "properties": {
      "intent": { "type": "string" },
      "draft": { "type": "string" }
    },
    "required": ["intent", "draft"],
    "additionalProperties": false
  }
}'
```

자세한 내용 및 구성 옵션은 [LLM Task](/tools/llm-task)를 참조하세요.

## 워크플로 파일 (.lobster)

Lobster는 `name`, `args`, `steps`, `env`, `condition`, `approval` 필드가 있는 YAML/JSON 워크플로 파일을 실행할 수 있습니다. OpenClaw 도구 호출에서 `pipeline`을 파일 경로로 설정하세요.

```yaml
name: inbox-triage
args:
  tag:
    default: "family"
steps:
  - id: collect
    command: inbox list --json
  - id: categorize
    command: inbox categorize --json
    stdin: $collect.stdout
  - id: approve
    command: inbox apply --approve
    stdin: $categorize.stdout
    approval: required
  - id: execute
    command: inbox apply --execute
    stdin: $categorize.stdout
    condition: $approve.approved
```

참고:

- `stdin: $step.stdout` 및 `stdin: $step.json`은 이전 단계의 출력을 전달합니다.
- `condition` (또는 `when`)은 `$step.approved`에서 단계를 게이트할 수 있습니다.

## Lobster 설치

OpenClaw 게이트웨이를 실행하는 **동일한 호스트**에 Lobster CLI를 설치하고([Lobster repo](https://github.com/openclaw/lobster) 참조), `lobster`가 `PATH`에 있는지 확인하세요.
사용자 지정 바이너리 위치를 사용하려면 도구 호출에서 **절대** `lobsterPath`를 전달하세요.

## 도구 활성화

Lobster는 **선택적** 플러그인 도구입니다(기본적으로 활성화되지 않음).

권장 (추가, 안전):

```json
{
  "tools": {
    "alsoAllow": ["lobster"]
  }
}
```

또는 에이전트별:

```json
{
  "agents": {
    "list": [
      {
        "id": "main",
        "tools": {
          "alsoAllow": ["lobster"]
        }
      }
    ]
  }
}
```

제한적인 allowlist 모드에서 실행하려는 경우가 아니면 `tools.allow: ["lobster"]` 사용을 피하세요.

참고: allowlist는 선택적 플러그인에 대해 옵트인입니다. allowlist에 플러그인 도구(예: `lobster`)만
명명하면 OpenClaw는 핵심 도구를 활성화 상태로 유지합니다. 핵심 도구를 제한하려면 allowlist에
원하는 핵심 도구 또는 그룹도 포함하세요.

## 예제: 이메일 분류

Lobster 없이:
```
User: "Check my email and draft replies"
→ openclaw calls gmail.list
→ LLM summarizes
→ User: "draft replies to #2 and #5"
→ LLM drafts
→ User: "send #2"
→ openclaw calls gmail.send
(repeat daily, no memory of what was triaged)
```

Lobster와 함께:
```json
{
  "action": "run",
  "pipeline": "email.triage --limit 20",
  "timeoutMs": 30000
}
```

JSON 엔벨로프 반환(잘림):
```json
{
  "ok": true,
  "status": "needs_approval",
  "output": [{ "summary": "5 need replies, 2 need action" }],
  "requiresApproval": {
    "type": "approval_request",
    "prompt": "Send 2 draft replies?",
    "items": [],
    "resumeToken": "..."
  }
}
```

사용자 승인 → 재개:
```json
{
  "action": "resume",
  "token": "<resumeToken>",
  "approve": true
}
```

하나의 워크플로. 결정론적. 안전.

## 도구 매개변수

### `run`

도구 모드에서 파이프라인을 실행합니다.

```json
{
  "action": "run",
  "pipeline": "gog.gmail.search --query 'newer_than:1d' | email.triage",
  "cwd": "/path/to/workspace",
  "timeoutMs": 30000,
  "maxStdoutBytes": 512000
}
```

인수가 있는 워크플로 파일 실행:

```json
{
  "action": "run",
  "pipeline": "/path/to/inbox-triage.lobster",
  "argsJson": "{\"tag\":\"family\"}"
}
```

### `resume`

승인 후 중단된 워크플로를 계속합니다.

```json
{
  "action": "resume",
  "token": "<resumeToken>",
  "approve": true
}
```

### 선택적 입력

- `lobsterPath`: Lobster 바이너리의 절대 경로(`PATH`를 사용하려면 생략).
- `cwd`: 파이프라인의 작업 디렉토리(현재 프로세스 작업 디렉토리로 기본 설정).
- `timeoutMs`: 이 기간을 초과하면 하위 프로세스를 종료합니다(기본값: 20000).
- `maxStdoutBytes`: stdout이 이 크기를 초과하면 하위 프로세스를 종료합니다(기본값: 512000).
- `argsJson`: `lobster run --args-json`에 전달되는 JSON 문자열(워크플로 파일만).

## 출력 엔벨로프

Lobster는 세 가지 상태 중 하나로 JSON 엔벨로프를 반환합니다:

- `ok` → 성공적으로 완료
- `needs_approval` → 일시 중지됨; 재개하려면 `requiresApproval.resumeToken`이 필요함
- `cancelled` → 명시적으로 거부되었거나 취소됨

도구는 `content`(예쁜 JSON)와 `details`(원시 객체) 모두에 엔벨로프를 표시합니다.

## 승인

`requiresApproval`이 있으면 프롬프트를 검사하고 결정하세요:

- `approve: true` → 재개하고 부작용 계속
- `approve: false` → 취소하고 워크플로 완료

사용자 지정 jq/heredoc 접착제 없이 JSON 미리보기를 승인 요청에 첨부하려면 `approve --preview-from-stdin --limit N`을 사용하세요. 이제 재개 토큰이 컴팩트합니다: Lobster는 상태 디렉토리 아래에 워크플로 재개 상태를 저장하고 작은 토큰 키를 반환합니다.

## OpenProse

OpenProse는 Lobster와 잘 어울립니다: `/prose`를 사용하여 다중 에이전트 준비를 조율한 다음 결정론적 승인을 위해 Lobster 파이프라인을 실행하세요. Prose 프로그램에 Lobster가 필요한 경우 `tools.subagents.tools`를 통해 서브 에이전트에 대해 `lobster` 도구를 허용하세요. [OpenProse](/prose)를 참조하세요.

## 안전

- **로컬 하위 프로세스만** — 플러그인 자체에서 네트워크 호출 없음.
- **비밀 없음** — Lobster는 OAuth를 관리하지 않습니다; OAuth를 수행하는 OpenClaw 도구를 호출합니다.
- **샌드박스 인식** — 도구 컨텍스트가 샌드박스화된 경우 비활성화됨.
- **강화됨** — `lobsterPath`는 지정된 경우 절대 경로여야 합니다; 타임아웃 및 출력 제한이 시행됩니다.

## 문제 해결

- **`lobster subprocess timed out`** → `timeoutMs`를 늘리거나 긴 파이프라인을 분할하세요.
- **`lobster output exceeded maxStdoutBytes`** → `maxStdoutBytes`를 높이거나 출력 크기를 줄이세요.
- **`lobster returned invalid JSON`** → 파이프라인이 도구 모드에서 실행되고 JSON만 인쇄하는지 확인하세요.
- **`lobster failed (code …)`** → 터미널에서 동일한 파이프라인을 실행하여 stderr을 검사하세요.

## 더 알아보기

- [Plugins](/plugin)
- [Plugin tool authoring](/plugins/agent-tools)

## 사례 연구: 커뮤니티 워크플로

공개 예제: 세 개의 Markdown 볼트(개인, 파트너, 공유)를 관리하는 "세컨드 브레인" CLI + Lobster 파이프라인. CLI는 통계, 수신함 목록 및 오래된 스캔을 위한 JSON을 출력합니다; Lobster는 이러한 명령을 `weekly-review`, `inbox-triage`, `memory-consolidation`, `shared-task-sync`와 같은 워크플로로 연결하며 각각 승인 게이트가 있습니다. AI는 사용 가능할 때 판단(분류)을 처리하고 그렇지 않으면 결정론적 규칙으로 폴백합니다.

- Thread: https://x.com/plattenschieber/status/2014508656335770033
- Repo: https://github.com/bloomedai/brain-cli
