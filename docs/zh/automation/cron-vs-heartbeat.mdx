---
summary: "选择心跳（heartbeat）和定时任务（cron）的指导"
read_when:
  - 决定如何调度重复任务
  - 设置后台监控或通知
  - 优化定期检查的 token 使用
---
# Cron vs Heartbeat：何时使用

心跳（heartbeat）和定时任务（cron jobs）都能让你按计划运行任务。本指南帮助你为你的用例选择合适的机制。

## 快速决策指南

| 用例 | 推荐 | 原因 |
|----------|-------------|-----|
| 每 30 分钟检查收件箱 | Heartbeat | 与其他检查批处理，上下文感知 |
| 每天早上 9 点准时发送报告 | Cron (isolated) | 需要精确时间 |
| 监控日历中即将到来的事件 | Heartbeat | 适合定期感知 |
| 每周运行深度分析 | Cron (isolated) | 独立任务，可使用不同模型 |
| 20 分钟后提醒我 | Cron (main, `--at`) | 单次精确定时 |
| 后台项目健康检查 | Heartbeat | 搭便车于现有周期 |

## Heartbeat：定期感知

心跳在**主会话**中按固定间隔运行（默认：30 分钟）。它们设计用于代理检查事项并浮现任何重要内容。

### 何时使用 heartbeat

- **多个定期检查**：不需要 5 个独立的 cron 作业来检查收件箱、日历、天气、通知和项目状态，单个心跳可以批量处理所有这些。
- **上下文感知决策**：代理拥有完整的主会话上下文，因此可以智能决定什么紧急、什么可以等待。
- **对话连续性**：心跳运行共享同一会话，因此代理记得最近的对话并可以自然地跟进。
- **低开销监控**：一个心跳替代许多小的轮询任务。

### Heartbeat 优势

- **批量多个检查**：一个代理回合可以一起检查收件箱、日历和通知。
- **减少 API 调用**：单个心跳比 5 个独立的 cron 作业更便宜。
- **上下文感知**：代理知道你一直在做什么，可以相应地优先处理。
- **智能抑制**：如果没有需要关注的内容，代理回复 `HEARTBEAT_OK`，不会发送消息。
- **自然时间**：根据队列负载略有漂移，这对大多数监控来说是可以接受的。

### Heartbeat 示例：HEARTBEAT.md 检查清单

```md
# Heartbeat checklist

- Check email for urgent messages
- Review calendar for events in next 2 hours
- If a background task finished, summarize results
- If idle for 8+ hours, send a brief check-in
```

代理在每次心跳时读取此内容并在一个回合中处理所有项目。

### 配置 heartbeat

```json5
{
  agents: {
    defaults: {
      heartbeat: {
        every: "30m",        // 间隔
        target: "last",      // 警报发送位置
        activeHours: { start: "08:00", end: "22:00" }  // 可选
      }
    }
  }
}
```

查看 [Heartbeat](/gateway/heartbeat) 了解完整配置。

## Cron：精确调度

Cron 作业在**精确时间**运行，可以在独立会话中运行而不影响主上下文。

### 何时使用 cron

- **需要精确时间**："每周一上午 9:00 发送此内容"（不是"9 点左右某个时间"）。
- **独立任务**：不需要对话上下文的任务。
- **不同模型/思考**：需要更强大模型的重型分析。
- **单次提醒**："20 分钟后提醒我"使用 `--at`。
- **嘈杂/频繁任务**：会使主会话历史混乱的任务。
- **外部触发器**：应该独立于代理是否活跃而运行的任务。

### Cron 优势

- **精确时间**：带时区支持的 5 字段 cron 表达式。
- **会话隔离**：在 `cron:<jobId>` 中运行而不污染主历史。
- **模型覆盖**：每个作业使用更便宜或更强大的模型。
- **发送控制**：可以直接发送到频道；默认情况下仍会向主会话发送摘要（可配置）。
- **不需要代理上下文**：即使主会话空闲或压缩也会运行。
- **单次支持**：`--at` 用于精确的未来时间戳。

### Cron 示例：每日早间简报

```bash
openclaw cron add \
  --name "Morning briefing" \
  --cron "0 7 * * *" \
  --tz "America/New_York" \
  --session isolated \
  --message "Generate today's briefing: weather, calendar, top emails, news summary." \
  --model opus \
  --deliver \
  --channel whatsapp \
  --to "+15551234567"
```

这在纽约时间上午 7:00 准时运行，使用 Opus 获得质量，并直接发送到 WhatsApp。

### Cron 示例：单次提醒

```bash
openclaw cron add \
  --name "Meeting reminder" \
  --at "20m" \
  --session main \
  --system-event "Reminder: standup meeting starts in 10 minutes." \
  --wake now \
  --delete-after-run
```

查看 [Cron jobs](/automation/cron-jobs) 了解完整 CLI 参考。

## 决策流程图

```
任务是否需要在精确时间运行？
  是 -> 使用 cron
  否 -> 继续...

任务是否需要与主会话隔离？
  是 -> 使用 cron (isolated)
  否 -> 继续...

此任务能否与其他定期检查批处理？
  是 -> 使用 heartbeat（添加到 HEARTBEAT.md）
  否 -> 使用 cron

这是单次提醒吗？
  是 -> 使用 cron 配合 --at
  否 -> 继续...

是否需要不同的模型或思考级别？
  是 -> 使用 cron (isolated) 配合 --model/--thinking
  否 -> 使用 heartbeat
```

## 结合使用

最高效的设置是**两者都用**：

1. **Heartbeat** 处理常规监控（收件箱、日历、通知），每 30 分钟批量处理一次。
2. **Cron** 处理精确调度（每日报告、每周回顾）和单次提醒。

### 示例：高效自动化设置

**HEARTBEAT.md**（每 30 分钟检查）：
```md
# Heartbeat checklist
- Scan inbox for urgent emails
- Check calendar for events in next 2h
- Review any pending tasks
- Light check-in if quiet for 8+ hours
```

**Cron jobs**（精确时间）：
```bash
# Daily morning briefing at 7am
openclaw cron add --name "Morning brief" --cron "0 7 * * *" --session isolated --message "..." --deliver

# Weekly project review on Mondays at 9am
openclaw cron add --name "Weekly review" --cron "0 9 * * 1" --session isolated --message "..." --model opus

# One-shot reminder
openclaw cron add --name "Call back" --at "2h" --session main --system-event "Call back the client" --wake now
```

## Lobster：带批准的确定性工作流

Lobster 是用于**多步骤工具流水线**的工作流运行时，需要确定性执行和显式批准。
当任务不止一个代理回合，并且你想要一个可恢复的工作流与人工检查点时使用它。

### Lobster 适用场景

- **多步自动化**：你需要固定的工具调用流水线，而不是一次性提示。
- **批准门控**：副作用应该暂停直到你批准，然后恢复。
- **可恢复运行**：继续暂停的工作流而无需重新运行早期步骤。

### 它如何与 heartbeat 和 cron 配对

- **Heartbeat/cron** 决定*何时*运行发生。
- **Lobster** 定义*哪些步骤*在运行开始后发生。

对于计划工作流，使用 cron 或 heartbeat 触发调用 Lobster 的代理回合。
对于临时工作流，直接调用 Lobster。

### 操作说明（来自代码）

- Lobster 在工具模式下作为**本地子进程**（`lobster` CLI）运行，并返回一个 **JSON 封装**。
- 如果工具返回 `needs_approval`，你使用 `resumeToken` 和 `approve` 标志恢复。
- 该工具是**可选插件**；通过 `tools.alsoAllow: ["lobster"]` 添加启用（推荐）。
- 如果你传递 `lobsterPath`，它必须是**绝对路径**。

查看 [Lobster](/tools/lobster) 了解完整用法和示例。

## 主会话 vs 隔离会话

心跳和 cron 都可以与主会话交互，但方式不同：

| | Heartbeat | Cron (main) | Cron (isolated) |
|---|---|---|---|
| 会话 | Main | Main（通过系统事件） | `cron:<jobId>` |
| 历史 | 共享 | 共享 | 每次运行全新 |
| 上下文 | 完整 | 完整 | 无（干净启动） |
| 模型 | 主会话模型 | 主会话模型 | 可覆盖 |
| 输出 | 如果不是 `HEARTBEAT_OK` 则发送 | 心跳提示 + 事件 | 摘要发布到主会话 |

### 何时使用主会话 cron

当你想要以下情况时使用 `--session main` 配合 `--system-event`：
- 提醒/事件出现在主会话上下文中
- 代理在下一次心跳时使用完整上下文处理它
- 无需单独的隔离运行

```bash
openclaw cron add \
  --name "Check project" \
  --every "4h" \
  --session main \
  --system-event "Time for a project health check" \
  --wake now
```

### 何时使用隔离 cron

当你想要以下情况时使用 `--session isolated`：
- 没有先前上下文的干净环境
- 不同的模型或思考设置
- 直接发送到频道的输出（摘要默认仍发布到主会话）
- 不会使主会话混乱的历史

```bash
openclaw cron add \
  --name "Deep analysis" \
  --cron "0 6 * * 0" \
  --session isolated \
  --message "Weekly codebase analysis..." \
  --model opus \
  --thinking high \
  --deliver
```

## 成本考虑

| 机制 | 成本概况 |
|-----------|--------------|
| Heartbeat | 每 N 分钟一个回合；随 HEARTBEAT.md 大小缩放 |
| Cron (main) | 向下一次心跳添加事件（无隔离回合） |
| Cron (isolated) | 每个作业完整代理回合；可使用更便宜模型 |

**提示**：
- 保持 `HEARTBEAT.md` 小巧以最小化 token 开销。
- 将类似检查批处理到 heartbeat 而不是多个 cron 作业。
- 如果你只想要内部处理，在 heartbeat 上使用 `target: "none"`。
- 对常规任务使用带更便宜模型的隔离 cron。

## 相关

- [Heartbeat](/gateway/heartbeat) - 完整心跳配置
- [Cron jobs](/automation/cron-jobs) - 完整 cron CLI 和 API 参考
- [System](/cli/system) - 系统事件 + 心跳控制
