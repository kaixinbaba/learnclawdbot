---
title: "Исследование памяти рабочего пространства"
summary: "Архитектура памяти с приоритетом оффлайн, использующая Markdown как канонический источник и производный индекс для структурированного воспроизведения"
---

# Память рабочего пространства v2 (оффлайн): исследовательские заметки

**Цель:** Рабочее пространство в стиле Clawd (`agents.defaults.workspace`, по умолчанию `~/.openclaw/workspace`), где "память" хранится как один файл Markdown в день (`memory/YYYY-MM-DD.md`) плюс небольшой набор стабильных файлов (например, `memory.md`, `SOUL.md`).

Этот документ предлагает архитектуру памяти с приоритетом оффлайн, которая сохраняет Markdown как канонический, проверяемый источник истины, но добавляет структурированное воспроизведение (поиск, сводки по сущностям, обновления уверенности) через производный индекс.

## Зачем менять?

Текущая настройка (один файл в день) отлично подходит для:

- Журналирования "только добавление"
- Редактирования человеком
- Надежности и аудируемости на основе git
- Низкой фрикционности захвата ("просто запишите")

Слабые стороны:

- Высокая полнота извлечения ("что мы решили о X?", "когда мы в последний раз пробовали Y?")
- Ответы, ориентированные на сущности ("расскажи мне об Alice / The Castle / warelay") без перечитывания многих файлов
- Стабильность мнения/предпочтения (и доказательства, когда оно меняется)
- Временные ограничения ("что было правдой в ноябре 2025?") и разрешение конфликтов

## Цели дизайна

- **Оффлайн:** работает без сети; может работать на ноутбуке/Castle; без зависимости от облака
- **Объяснимо:** извлеченные элементы должны быть атрибутируемыми (файл + местоположение) и отделимыми от вывода
- **Низкие церемонии:** ежедневное логирование остается Markdown, без тяжелой работы со схемой
- **Инкрементально:** v1 полезен только с FTS; семантический/векторный и графы являются опциональными обновлениями
- **Дружелюбно к агенту:** упрощает "воспроизведение в рамках бюджета токенов" (возвращает небольшие пакеты фактов)

## Модель Полярной звезды (Hindsight × Letta)

Две части для смешивания:

### Контрольный цикл в стиле Letta/MemGPT

- Всегда держите небольшое "ядро" в контексте (персона + ключевые факты о пользователе)
- Все остальное вне контекста и извлекается через инструменты
- Записи в память — это явные вызовы инструментов (append/replace/insert), сохраняются, затем повторно вводятся в следующем ходе

### Субстрат памяти в стиле Hindsight

- Разделить наблюдаемое vs верованное vs суммированное
- Поддержка retain/recall/reflect
- Мнения с уверенностью, которые могут эволюционировать с доказательствами
- Извлечение с учетом сущностей + временные запросы (даже без полных графов знаний)

## Предлагаемая архитектура (Markdown как источник истины + производный индекс)

### Канонический магазин (git-дружественный)

Сохраните `~/.openclaw/workspace` как каноническую человекочитаемую память.

Предлагаемая структура рабочего пространства:

```
~/.openclaw/workspace/
  memory.md                # маленький: долговечные факты + предпочтения (core-ish)
  memory/
    YYYY-MM-DD.md          # ежедневный лог (добавление; нарратив)
  bank/                    # "типизированные" страницы памяти (стабильные, проверяемые)
    world.md               # объективные факты о мире
    experience.md          # что делал агент (от первого лица)
    opinions.md            # субъективные предпочтения/суждения + уверенность + указатели на доказательства
    entities/
      Peter.md
      The-Castle.md
      warelay.md
      ...
```

Примечания:

- Ежедневный лог остается ежедневным логом. Нет необходимости превращать его в JSON
- Файлы `bank/` курируются, создаются заданиями рефлексии и все еще могут редактироваться вручную
- `memory.md` остается "маленьким + core-ish": то, что вы хотите, чтобы Clawd видел в каждой сессии

### Производный магазин (машинное воспроизведение)

Добавьте производный индекс под рабочим пространством (не обязательно отслеживается git):

```
~/.openclaw/workspace/.memory/index.sqlite
```

Поддерживается:

- Схема SQLite для фактов + связи сущностей + метаданные мнений
- SQLite FTS5 для лексического воспроизведения (быстро, крошечно, оффлайн)
- Опциональная таблица встраиваний для семантического воспроизведения (все еще оффлайн)

Индекс всегда восстанавливается из Markdown.

## Retain / Recall / Reflect (операционный цикл)

### Retain: нормализация ежедневных логов в "факты"

Ключевая идея Hindsight, которая здесь важна: хранить нарративные, самодостаточные факты, а не крошечные фрагменты.

Практическое правило для `memory/YYYY-MM-DD.md`:

- В конце дня (или во время), добавьте секцию `## Retain` с 2–5 пунктами, которые:
  - Нарративны (сохранен контекст между ходами)
  - Самодостаточны (имеют смысл позже как самостоятельные)
  - Помечены типом + упоминаниями сущностей

Пример:

```markdown
## Retain
- W @Peter: В настоящее время в Марракеше (27 ноября – 1 декабря 2025) на день рождения Энди.
- B @warelay: Я исправил сбой Baileys WS, обернув обработчики connection.update в try/catch (см. memory/2025-11-27.md).
- O(c=0.95) @Peter: Предпочитает краткие ответы (<1500 символов) в WhatsApp; длинный контент идет в файлы.
```

Минимальный парсинг:

- Префикс типа: `W` (мир), `B` (опыт/биографический), `O` (мнение), `S` (наблюдение/сводка; обычно генерируется)
- Сущности: `@Peter`, `@warelay` и т. д. (слаги отображаются в `bank/entities/*.md`)
- Уверенность мнения: `O(c=0.0..1.0)` опционально

Если вы не хотите, чтобы авторы об этом думали: задание рефлексии может вывести эти пункты из остальной части лога, но наличие явной секции `## Retain` — самый простой "рычаг качества".

### Recall: запросы к производному индексу

Воспроизведение должно поддерживать:

- **Лексическое:** "найти точные термины / имена / команды" (FTS5)
- **Сущность:** "расскажи мне об X" (страницы сущностей + факты, связанные с сущностями)
- **Временное:** "что случилось около 27 ноября" / "с прошлой недели"
- **Мнение:** "что предпочитает Питер?" (с уверенностью + доказательствами)

Формат возврата должен быть дружелюбным к агенту и ссылаться на источники:

- kind (`world`|`experience`|`opinion`|`observation`)
- timestamp (исходный день или извлеченный временной диапазон, если присутствует)
- entities (`["Peter","warelay"]`)
- content (нарративный факт)
- source (`memory/2025-11-27.md#L12` и т.д.)

### Reflect: создание стабильных страниц + обновление убеждений

Рефлексия — это запланированное задание (ежедневное или heartbeat ultrathink), которое:

- Обновляет `bank/entities/*.md` из недавних фактов (сводки по сущностям)
- Обновляет уверенность `bank/opinions.md` на основе подкрепления/противоречия
- Опционально предлагает правки в `memory.md` ("core-ish" долговечные факты)

Эволюция мнения (простая, объяснимая):

- У каждого мнения есть:
  - Утверждение
  - Уверенность `c ∈ [0,1]`
  - `last_updated`
  - Ссылки на доказательства (поддерживающие + противоречащие ID фактов)

- Когда прибывают новые факты:
  - Найти кандидатов мнений по перекрытию сущностей + сходству (сначала FTS, позже встраивания)
  - Обновить уверенность небольшими дельтами; большие скачки требуют сильного противоречия + повторяющихся доказательств

## Интеграция CLI: автономная vs глубокая интеграция

Рекомендация: глубокая интеграция в OpenClaw, но сохранение отделяемой основной библиотеки.

### Почему интегрироваться в OpenClaw?

- OpenClaw уже знает:
  - Путь к рабочему пространству (`agents.defaults.workspace`)
  - Модель сессии + heartbeats
  - Паттерны логирования + устранения неполадок

- Вы хотите, чтобы сам агент вызывал инструменты:
  - `openclaw memory recall "…" --k 25 --since 30d`
  - `openclaw memory reflect --since 7d`

### Почему все же разделить библиотеку?

- Сохранить логику памяти тестируемой без gateway/runtime
- Повторное использование из других контекстов (локальные скрипты, будущее настольное приложение и т.д.)

Форма: Инструментарий памяти предназначен быть небольшим слоем CLI + библиотека, но это только исследовательское.

## "S-Collide" / SuCo: когда использовать (исследование)

Если "S-Collide" относится к SuCo (Subspace Collision): это подход извлечения ANN, который нацелен на сильные компромиссы recall/latency, используя обученные/структурированные столкновения в подпространствах (статья: arXiv 2411.14754, 2024).

Прагматический взгляд для `~/.openclaw/workspace`:

- Не начинайте с SuCo
- Начните с SQLite FTS + (опционально) простые встраивания; вы сразу получите большинство UX побед
- Рассматривайте решения класса SuCo/HNSW/ScaNN только когда:
  - Корпус большой (десятки/сотни тысяч фрагментов)
  - Поиск встраиваний методом перебора становится слишком медленным
  - Качество воспроизведения значительно ограничено лексическим поиском

Оффлайн-дружественные альтернативы (в порядке возрастания сложности):

1. SQLite FTS5 + фильтры метаданных (нулевой ML)
2. Встраивания + перебор (работает удивительно далеко, если количество фрагментов низкое)
3. Индекс HNSW (распространенный, надежный; требует привязки библиотеки)
4. SuCo (исследовательского уровня; привлекателен, если есть надежная реализация, которую можно встроить)

Открытый вопрос:

- Какая лучшая оффлайн модель встраивания для "памяти личного помощника" на ваших машинах (ноутбук + настольный компьютер)?
- Если у вас уже есть Ollama: встраивайте с локальной моделью; в противном случае поставьте небольшую модель встраивания в инструментальной цепочке

## Минимальный полезный пилот

Если вы хотите минимальную, но все еще полезную версию:

- Добавьте страницы сущностей `bank/` и секцию `## Retain` в ежедневных логах
- Используйте SQLite FTS для воспроизведения с цитатами (путь + номера строк)
- Добавляйте встраивания только если качество воспроизведения или масштаб требуют этого

## Ссылки

- **Концепции Letta / MemGPT:** "блоки основной памяти" + "архивная память" + самоедактирующая память, управляемая инструментами
- **Технический отчет Hindsight:** "retain / recall / reflect", четырехсетевая память, извлечение нарративных фактов, эволюция уверенности мнений
- **SuCo:** arXiv 2411.14754 (2024): извлечение приблизительного ближайшего соседа "Subspace Collision"
