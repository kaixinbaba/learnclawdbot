---
summary: "Браузерный пользовательский интерфейс управления для шлюза (чат, ноды, конфигурация)"
read_when:
  - Вы хотите управлять шлюзом из браузера
  - Вам нужен доступ к Tailnet без SSH-туннелей
---
# Интерфейс управления (браузер)

Интерфейс управления — это небольшое одностраничное приложение **Vite + Lit**, обслуживаемое шлюзом:

- по умолчанию: `http://<host>:18789/`
- опциональный префикс: установите `gateway.controlUi.basePath` (например `/openclaw`)

Он общается **напрямую с WebSocket шлюза** на том же порту.

## Быстрое открытие (локально)

Если шлюз работает на том же компьютере, откройте:

- http://127.0.0.1:18789/ (или http://localhost:18789/)

Если страница не загружается, сначала запустите шлюз: `openclaw gateway`.

Аутентификация предоставляется во время рукопожатия WebSocket через:
- `connect.params.auth.token`
- `connect.params.auth.password`
Панель настроек панели управления позволяет сохранить токен; пароли не сохраняются.
Мастер адаптации генерирует токен шлюза по умолчанию, поэтому вставьте его сюда при первом подключении.

## Что он может делать (сегодня)
- Чат с моделью через WebSocket шлюза (`chat.history`, `chat.send`, `chat.abort`, `chat.inject`)
- Потоковая передача вызовов инструментов + карточки вывода живых инструментов в чате (события агента)
- Каналы: статус WhatsApp/Telegram/Discord/Slack + канальных плагинов (Mattermost и т.д.) + вход по QR + конфигурация для каждого канала (`channels.status`, `web.login.*`, `config.patch`)
- Инстансы: список присутствия + обновление (`system-presence`)
- Сессии: список + переопределения thinking/verbose для каждой сессии (`sessions.list`, `sessions.patch`)
- Задачи Cron: список/добавить/запустить/включить/отключить + история запусков (`cron.*`)
- Навыки: статус, включить/отключить, установить, обновления API-ключей (`skills.*`)
- Ноды: список + возможности (`node.list`)
- Подтверждения Exec: редактировать списки разрешений шлюза или ноды + политику запроса для `exec host=gateway/node` (`exec.approvals.*`)
- Конфигурация: просмотр/редактирование `~/.openclaw/openclaw.json` (`config.get`, `config.set`)
- Конфигурация: применение + перезапуск с валидацией (`config.apply`) и пробуждение последней активной сессии
- Запись конфигурации включает защиту base-hash для предотвращения затирания одновременных правок
- Схема конфигурации + рендеринг форм (`config.schema`, включая схемы плагинов + каналов); редактор необработанного JSON остается доступным
- Отладка: снапшоты status/health/models + лог событий + ручные RPC-вызовы (`status`, `health`, `models.list`)
- Логи: живое отслеживание файловых логов шлюза с фильтром/экспортом (`logs.tail`)
- Обновление: запуск обновления пакета/git + перезапуск (`update.run`) с отчетом о перезапуске

## Поведение чата

- `chat.send` **неблокирующий**: он немедленно подтверждает с `\{ runId, status: "started" \}`, и ответ передается через события `chat`.
- Повторная отправка с тем же `idempotencyKey` возвращает `\{ status: "in_flight" \}` во время работы и `\{ status: "ok" \}` после завершения.
- `chat.inject` добавляет заметку ассистента в транскрипт сессии и транслирует событие `chat` только для обновления UI (без запуска агента, без доставки в канал).
- Остановка:
  - Нажмите **Stop** (вызывает `chat.abort`)
  - Введите `/stop` (или `stop|esc|abort|wait|exit|interrupt`) для прерывания вне полосы
  - `chat.abort` поддерживает `\{ sessionKey \}` (без `runId`) для прерывания всех активных запусков для этой сессии

## Доступ к Tailnet (рекомендуется)

### Интегрированный Tailscale Serve (предпочтительно)

Держите шлюз на loopback и пусть Tailscale Serve проксирует его с HTTPS:

```bash
openclaw gateway --tailscale serve
```

Откройте:
- `https://<magicdns>/` (или ваш настроенный `gateway.controlUi.basePath`)

По умолчанию запросы Serve могут аутентифицироваться через заголовки идентификации Tailscale (`tailscale-user-login`), когда `gateway.auth.allowTailscale` равно `true`. OpenClaw проверяет идентификацию, разрешая адрес `x-forwarded-for` с помощью `tailscale whois` и сопоставляя его с заголовком, и принимает их только когда запрос приходит на loopback с заголовками `x-forwarded-*` от Tailscale. Установите `gateway.auth.allowTailscale: false` (или принудительно `gateway.auth.mode: "password"`), если хотите требовать токен/пароль даже для трафика Serve.

### Привязка к tailnet + токен

```bash
openclaw gateway --bind tailnet --token "$(openssl rand -hex 32)"
```

Затем откройте:
- `http://<tailscale-ip>:18789/` (или ваш настроенный `gateway.controlUi.basePath`)

Вставьте токен в настройки UI (отправляется как `connect.params.auth.token`).

## Небезопасный HTTP

Если вы открываете панель управления через простой HTTP (`http://<lan-ip>` или `http://<tailscale-ip>`), браузер работает в **небезопасном контексте** и блокирует WebCrypto. По умолчанию OpenClaw **блокирует** подключения к интерфейсу управления без идентификации устройства.

**Рекомендуемое исправление:** используйте HTTPS (Tailscale Serve) или откройте UI локально:
- `https://<magicdns>/` (Serve)
- `http://127.0.0.1:18789/` (на хосте шлюза)

**Пример понижения (только токен через HTTP):**

```json5
{
  gateway: {
    controlUi: { allowInsecureAuth: true },
    bind: "tailnet",
    auth: { mode: "token", token: "replace-me" }
  }
}
```

Это отключает идентификацию устройства + сопряжение для интерфейса управления (даже через HTTPS). Используйте только если доверяете сети.

См. [Tailscale](/gateway/tailscale) для руководства по настройке HTTPS.

## Сборка UI

Шлюз обслуживает статические файлы из `dist/control-ui`. Соберите их с помощью:

```bash
pnpm ui:build # автоматически устанавливает зависимости UI при первом запуске
```

Опциональная абсолютная база (когда вам нужны фиксированные URL активов):

```bash
OPENCLAW_CONTROL_UI_BASE_PATH=/openclaw/ pnpm ui:build
```

Для локальной разработки (отдельный dev-сервер):

```bash
pnpm ui:dev # автоматически устанавливает зависимости UI при первом запуске
```

Затем направьте UI на URL вашего WebSocket шлюза (например `ws://127.0.0.1:18789`).

## Отладка/тестирование: dev-сервер + удаленный шлюз

Интерфейс управления — это статические файлы; цель WebSocket настраивается и может отличаться от HTTP-источника. Это удобно, когда вам нужен dev-сервер Vite локально, но шлюз работает в другом месте.

1) Запустите dev-сервер UI: `pnpm ui:dev`
2) Откройте URL вроде:

```text
http://localhost:5173/?gatewayUrl=ws://<gateway-host>:18789
```

Опциональная одноразовая аутентификация (если требуется):

```text
http://localhost:5173/?gatewayUrl=wss://<gateway-host>:18789&token=<gateway-token>
```

Примечания:
- `gatewayUrl` сохраняется в localStorage после загрузки и удаляется из URL.
- `token` сохраняется в localStorage; `password` хранится только в памяти.
- Используйте `wss://`, когда шлюз находится за TLS (Tailscale Serve, HTTPS-прокси и т.д.).

Детали настройки удаленного доступа: [Удаленный доступ](/gateway/remote).
