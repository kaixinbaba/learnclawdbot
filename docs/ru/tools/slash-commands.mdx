---
summary: "Косые команды: текст vs нативные, конфигурация и поддерживаемые команды"
read_when:
  - Использование или настройка команд чата
  - Отладка маршрутизации команд или разрешений
---
# Косые команды

Команды обрабатываются Шлюзом. Большинство команд должны быть отправлены как **отдельное** сообщение, начинающееся с `/`.
Команда bash только для хоста использует `! <cmd>` (с `/bash <cmd>` как алиасом).

Существует две связанные системы:

- **Команды**: отдельные `/...` сообщения.
- **Директивы**: `/think`, `/verbose`, `/reasoning`, `/elevated`, `/exec`, `/model`, `/queue`.
  - Директивы удаляются из сообщения до того, как модель его увидит.
  - В обычных сообщениях чата (не только директива) они рассматриваются как "встроенные подсказки" и **не** сохраняют настройки сессии.
  - В сообщениях только с директивами (сообщение содержит только директивы) они сохраняются в сессию и отвечают подтверждением.
  - Директивы применяются только для **авторизованных отправителей** (белые списки каналов/сопряжение плюс `commands.useAccessGroups`).
    Неавторизованные отправители видят директивы как обычный текст.

Также есть несколько **встроенных сокращений** (только авторизованные/разрешённые отправители): `/help`, `/commands`, `/status`, `/whoami` (`/id`).
Они выполняются немедленно, удаляются до того, как модель увидит сообщение, и оставшийся текст продолжается через обычный поток.

## Конфигурация

```json5
{
  commands: {
    native: "auto",
    nativeSkills: "auto",
    text: true,
    bash: false,
    bashForegroundMs: 2000,
    config: false,
    debug: false,
    restart: false,
    useAccessGroups: true
  }
}
```

- `commands.text` (по умолчанию `true`) включает разбор `/...` в сообщениях чата.
  - На поверхностях без нативных команд (WhatsApp/WebChat/Signal/iMessage/Google Chat/MS Teams) текстовые команды всё ещё работают, даже если вы установите это в `false`.
- `commands.native` (по умолчанию `"auto"`) регистрирует нативные команды.
  - Auto: включено для Discord/Telegram; выключено для Slack (пока вы не добавите косые команды); игнорируется для провайдеров без нативной поддержки.
  - Установите `channels.discord.commands.native`, `channels.telegram.commands.native` или `channels.slack.commands.native` для переопределения для каждого провайдера (bool или `"auto"`).
  - `false` очищает ранее зарегистрированные команды на Discord/Telegram при запуске. Команды Slack управляются в приложении Slack и не удаляются автоматически.
- `commands.nativeSkills` (по умолчанию `"auto"`) регистрирует **команды навыков** нативно, когда поддерживается.
  - Auto: включено для Discord/Telegram; выключено для Slack (Slack требует создания косой команды для каждого навыка).
  - Установите `channels.discord.commands.nativeSkills`, `channels.telegram.commands.nativeSkills` или `channels.slack.commands.nativeSkills` для переопределения для каждого провайдера (bool или `"auto"`).
- `commands.bash` (по умолчанию `false`) включает `! <cmd>` для запуска команд shell хоста (`/bash <cmd>` — алиас; требует белых списков `tools.elevated`).
- `commands.bashForegroundMs` (по умолчанию `2000`) контролирует, как долго bash ждёт перед переключением в фоновый режим (`0` переходит в фон немедленно).
- `commands.config` (по умолчанию `false`) включает `/config` (читает/записывает `openclaw.json`).
- `commands.debug` (по умолчанию `false`) включает `/debug` (переопределения только во время выполнения).
- `commands.useAccessGroups` (по умолчанию `true`) применяет белые списки/политики для команд.

## Список команд

Текст + нативные (когда включено):
- `/help`
- `/commands`
- `/skill <name> [input]` (запустить навык по имени)
- `/status` (показать текущий статус; включает использование/квоту провайдера для текущего провайдера модели, когда доступно)
- `/allowlist` (список/добавить/удалить записи белого списка)
- `/approve <id> allow-once|allow-always|deny` (разрешить запросы на одобрение exec)
- `/context [list|detail|json]` (объяснить "контекст"; `detail` показывает размер для каждого файла + для каждого инструмента + для каждого навыка + системного промпта)
- `/whoami` (показать ваш ID отправителя; алиас: `/id`)
- `/subagents list|stop|log|info|send` (проверить, остановить, логировать или отправлять сообщения запускам субагентов для текущей сессии)
- `/config show|get|set|unset` (сохранить конфигурацию на диск, только владелец; требует `commands.config: true`)
- `/debug show|set|unset|reset` (переопределения во время выполнения, только владелец; требует `commands.debug: true`)
- `/usage off|tokens|full|cost` (подвал использования для каждого ответа или локальная сводка стоимости)
- `/tts off|always|inbound|tagged|status|provider|limit|summary|audio` (управление TTS; смотрите [/tts](/tts))
  - Discord: нативная команда — `/voice` (Discord резервирует `/tts`); текст `/tts` всё ещё работает.
- `/stop`
- `/restart`
- `/dock-telegram` (алиас: `/dock_telegram`) (переключить ответы на Telegram)
- `/dock-discord` (алиас: `/dock_discord`) (переключить ответы на Discord)
- `/dock-slack` (алиас: `/dock_slack`) (переключить ответы на Slack)
- `/activation mention|always` (только группы)
- `/send on|off|inherit` (только владелец)
- `/reset` или `/new [model]` (опциональная подсказка модели; остаток передаётся)
- `/think <off|minimal|low|medium|high|xhigh>` (динамический выбор по модели/провайдеру; алиасы: `/thinking`, `/t`)
- `/verbose on|full|off` (алиас: `/v`)
- `/reasoning on|off|stream` (алиас: `/reason`; когда включено, отправляет отдельное сообщение с префиксом `Reasoning:`; `stream` = только черновик Telegram)
- `/elevated on|off|ask|full` (алиас: `/elev`; `full` пропускает одобрения exec)
- `/exec host=<sandbox|gateway|node> security=<deny|allowlist|full> ask=<off|on-miss|always> node=<id>` (отправьте `/exec` для показа текущего)
- `/model <name>` (алиас: `/models`; или `/<alias>` из `agents.defaults.models.*.alias`)
- `/queue <mode>` (плюс опции вроде `debounce:2s cap:25 drop:summarize`; отправьте `/queue` для просмотра текущих настроек)
- `/bash <command>` (только хост; алиас для `! <command>`; требует `commands.bash: true` + белых списков `tools.elevated`)

Только текст:
- `/compact [instructions]` (смотрите [/concepts/compaction](/concepts/compaction))
- `! <command>` (только хост; по одному за раз; используйте `!poll` + `!stop` для долго работающих задач)
- `!poll` (проверить вывод / статус; принимает опциональный `sessionId`; `/bash poll` также работает)
- `!stop` (остановить работающую задачу bash; принимает опциональный `sessionId`; `/bash stop` также работает)

Примечания:
- Команды принимают опциональный `:` между командой и аргументами (например, `/think: high`, `/send: on`, `/help:`).
- `/new <model>` принимает алиас модели, `provider/model` или имя провайдера (нечёткое совпадение); если нет совпадения, текст рассматривается как тело сообщения.
- Для полной разбивки использования провайдера используйте `openclaw status --usage`.
- `/allowlist add|remove` требует `commands.config=true` и соблюдает `configWrites` канала.
- `/usage` контролирует подвал использования для каждого ответа; `/usage cost` печатает локальную сводку стоимости из логов сессий OpenClaw.
- `/restart` отключен по умолчанию; установите `commands.restart: true` для его включения.
- `/verbose` предназначен для отладки и дополнительной видимости; держите его **выключенным** при обычном использовании.
- `/reasoning` (и `/verbose`) рискованны в настройках группы: они могут раскрыть внутреннее рассуждение или вывод инструментов, которые вы не намеревались раскрывать. Предпочитайте держать их выключенными, особенно в групповых чатах.
- **Быстрый путь:** сообщения только с командами от отправителей из белого списка обрабатываются немедленно (обход очереди + модель).
- **Управление упоминанием группы:** сообщения только с командами от отправителей из белого списка обходят требования упоминания.
- **Встроенные сокращения (только авторизованные отправители):** определённые команды также работают при встраивании в обычное сообщение и удаляются до того, как модель увидит оставшийся текст.
  - Пример: `привет /status` вызывает ответ статуса, и оставшийся текст продолжается через обычный поток.
- В настоящее время: `/help`, `/commands`, `/status`, `/whoami` (`/id`).
- Неавторизованные сообщения только с командами молча игнорируются, и встроенные токены `/...` рассматриваются как обычный текст.
- **Команды навыков:** навыки `user-invocable` раскрываются как косые команды. Имена санитизированы до `a-z0-9_` (макс 32 символа); коллизии получают числовые суффиксы (например, `_2`).
  - `/skill <name> [input]` запускает навык по имени (полезно, когда ограничения нативных команд предотвращают команды для каждого навыка).
  - По умолчанию команды навыков пересылаются модели как обычный запрос.
  - Навыки могут опционально объявлять `command-dispatch: tool` для маршрутизации команды напрямую к инструменту (детерминистично, без модели).
  - Пример: `/prose` (плагин OpenProse) — смотрите [OpenProse](/prose).
- **Аргументы нативных команд:** Discord использует автозаполнение для динамических опций (и кнопочные меню, когда вы опускаете обязательные аргументы). Telegram и Slack показывают кнопочное меню, когда команда поддерживает выбор, и вы опускаете аргумент.

## Поверхности использования (что показывается где)

- **Использование/квота провайдера** (пример: "Claude 80% осталось") показывается в `/status` для текущего провайдера модели, когда отслеживание использования включено.
- **Токены/стоимость для каждого ответа** контролируются через `/usage off|tokens|full` (добавляется к обычным ответам).
- `/model status` касается **моделей/аутентификации/конечных точек**, а не использования.

## Выбор модели (`/model`)

`/model` реализован как директива.

Примеры:

```
/model
/model list
/model 3
/model openai/gpt-5.2
/model opus@anthropic:default
/model status
```

Примечания:
- `/model` и `/model list` показывают компактный, пронумерованный выбор (семейство моделей + доступные провайдеры).
- `/model <#>` выбирает из этого выбора (и предпочитает текущего провайдера, когда возможно).
- `/model status` показывает подробный вид, включая настроенную конечную точку провайдера (`baseUrl`) и режим API (`api`), когда доступно.

## Переопределения отладки

`/debug` позволяет установить **переопределения конфигурации только во время выполнения** (память, не диск). Только владелец. Отключено по умолчанию; включите с `commands.debug: true`.

Примеры:

```
/debug show
/debug set messages.responsePrefix="[openclaw]"
/debug set channels.whatsapp.allowFrom=["+1555","+4477"]
/debug unset messages.responsePrefix
/debug reset
```

Примечания:
- Переопределения применяются немедленно к новым чтениям конфигурации, но **не** записываются в `openclaw.json`.
- Используйте `/debug reset` для очистки всех переопределений и возврата к конфигурации на диске.

## Обновления конфигурации

`/config` записывает в вашу конфигурацию на диске (`openclaw.json`). Только владелец. Отключено по умолчанию; включите с `commands.config: true`.

Примеры:

```
/config show
/config show messages.responsePrefix
/config get messages.responsePrefix
/config set messages.responsePrefix="[openclaw]"
/config unset messages.responsePrefix
```

Примечания:
- Конфигурация проверяется перед записью; недопустимые изменения отклоняются.
- Обновления `/config` сохраняются при перезапусках.

## Примечания к поверхностям

- **Текстовые команды** выполняются в обычной сессии чата (DM делятся `main`, группы имеют свою собственную сессию).
- **Нативные команды** используют изолированные сессии:
  - Discord: `agent:<agentId>:discord:slash:<userId>`
  - Slack: `agent:<agentId>:slack:slash:<userId>` (префикс настраивается через `channels.slack.slashCommand.sessionPrefix`)
  - Telegram: `telegram:slash:<userId>` (нацелен на сессию чата через `CommandTargetSessionKey`)
- **`/stop`** нацелен на активную сессию чата, чтобы она могла прервать текущий запуск.
- **Slack:** `channels.slack.slashCommand` всё ещё поддерживается для одной команды в стиле `/openclaw`. Если вы включите `commands.native`, вы должны создать одну косую команду Slack для каждой встроенной команды (те же имена, что и `/help`). Меню аргументов команд для Slack доставляются как эфемерные кнопки Block Kit.
