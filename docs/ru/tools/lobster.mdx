---
title: Lobster
summary: "Типизированная среда выполнения рабочих процессов для OpenClaw с возобновляемыми шлюзами одобрения."
description: Типизированная среда выполнения рабочих процессов для OpenClaw — композиционные конвейеры со шлюзами одобрения.
read_when:
  - Вы хотите детерминированные многошаговые рабочие процессы с явными одобрениями
  - Вам нужно возобновить рабочий процесс без повторного запуска более ранних шагов
---

# Lobster

Lobster — это оболочка рабочего процесса, которая позволяет OpenClaw выполнять многошаговые последовательности инструментов как одну детерминированную операцию с явными контрольными точками одобрения.

## Зацепка

Ваш ассистент может создавать инструменты, которые управляют им самим. Попросите рабочий процесс, и через 30 минут у вас есть CLI плюс конвейеры, которые выполняются как один вызов. Lobster — это недостающая часть: детерминированные конвейеры, явные одобрения и возобновляемое состояние.

## Почему

Сегодня сложные рабочие процессы требуют множества вызовов инструментов туда и обратно. Каждый вызов стоит токенов, и LLM должна оркестрировать каждый шаг. Lobster переносит эту оркестрацию в типизированную среду выполнения:

- **Один вызов вместо многих**: OpenClaw выполняет один вызов инструмента Lobster и получает структурированный результат.
- **Встроенные одобрения**: Побочные эффекты (отправка email, публикация комментария) останавливают рабочий процесс до явного одобрения.
- **Возобновляемость**: Остановленные рабочие процессы возвращают токен; одобрите и возобновите без повторного запуска всего.

## Почему DSL вместо обычных программ?

Lobster намеренно маленький. Цель не "новый язык", это предсказуемая, дружественная к ИИ спецификация конвейера с одобрениями и токенами возобновления первого класса.

- **Одобрение/возобновление встроено**: Обычная программа может спросить человека, но она не может *приостановиться и возобновиться* с долговечным токеном без того, чтобы вы изобретали эту среду выполнения самостоятельно.
- **Детерминизм + аудируемость**: Конвейеры — это данные, поэтому их легко логировать, сравнивать, воспроизводить и просматривать.
- **Ограниченная поверхность для ИИ**: Крошечная грамматика + JSON трубы уменьшают "творческие" пути кода и делают валидацию реалистичной.
- **Встроенная политика безопасности**: Тайм-ауты, ограничения вывода, проверки изолированной среды и списки разрешений применяются средой выполнения, а не каждым скриптом.
- **Все еще программируемо**: Каждый шаг может вызывать любой CLI или скрипт. Если вы хотите JS/TS, генерируйте файлы `.lobster` из кода.

## Как это работает

OpenClaw запускает локальный CLI `lobster` в **режиме инструмента** и парсит JSON конверт из stdout. Если конвейер приостанавливается для одобрения, инструмент возвращает `resumeToken`, чтобы вы могли продолжить позже.

## Паттерн: маленький CLI + JSON трубы + одобрения

Создавайте крошечные команды, которые говорят на JSON, затем свяжите их в один вызов Lobster. (Примеры имен команд ниже — замените своими собственными.)

```bash
inbox list --json
inbox categorize --json
inbox apply --json
```

```json
{
  "action": "run",
  "pipeline": "exec --json --shell 'inbox list --json' | exec --stdin json --shell 'inbox categorize --json' | exec --stdin json --shell 'inbox apply --json' | approve --preview-from-stdin --limit 5 --prompt 'Apply changes?'",
  "timeoutMs": 30000
}
```

Если конвейер запрашивает одобрение, возобновите с токеном:

```json
{
  "action": "resume",
  "token": "<resumeToken>",
  "approve": true
}
```

ИИ запускает рабочий процесс; Lobster выполняет шаги. Шлюзы одобрения сохраняют побочные эффекты явными и аудируемыми.

Пример: отображение входных элементов в вызовы инструментов:

```bash
gog.gmail.search --query 'newer_than:1d' \
  | openclaw.invoke --tool message --action send --each --item-key message --args-json '{"provider":"telegram","to":"..."}'
```

## Шаги LLM только для JSON (llm-task)

Для рабочих процессов, которым нужен **структурированный шаг LLM**, включите опциональный инструмент плагина `llm-task` и вызовите его из Lobster. Это сохраняет рабочий процесс детерминированным, позволяя при этом классифицировать/суммировать/черновик с моделью.

Включите инструмент:

```json
{
  "plugins": {
    "entries": {
      "llm-task": { "enabled": true }
    }
  },
  "agents": {
    "list": [
      {
        "id": "main",
        "tools": { "allow": ["llm-task"] }
      }
    ]
  }
}
```

Используйте его в конвейере:

```lobster
openclaw.invoke --tool llm-task --action json --args-json '{
  "prompt": "Given the input email, return intent and draft.",
  "input": { "subject": "Hello", "body": "Can you help?" },
  "schema": {
    "type": "object",
    "properties": {
      "intent": { "type": "string" },
      "draft": { "type": "string" }
    },
    "required": ["intent", "draft"],
    "additionalProperties": false
  }
}'
```

См. [LLM Task](/tools/llm-task) для деталей и опций конфигурации.

## Файлы рабочих процессов (.lobster)

Lobster может выполнять файлы рабочих процессов YAML/JSON с полями `name`, `args`, `steps`, `env`, `condition` и `approval`. В вызовах инструмента OpenClaw установите `pipeline` на путь файла.

```yaml
name: inbox-triage
args:
  tag:
    default: "family"
steps:
  - id: collect
    command: inbox list --json
  - id: categorize
    command: inbox categorize --json
    stdin: $collect.stdout
  - id: approve
    command: inbox apply --approve
    stdin: $categorize.stdout
    approval: required
  - id: execute
    command: inbox apply --execute
    stdin: $categorize.stdout
    condition: $approve.approved
```

Примечания:

- `stdin: $step.stdout` и `stdin: $step.json` передают вывод предыдущего шага.
- `condition` (или `when`) может контролировать шаги на основе `$step.approved`.

## Установка Lobster

Установите CLI Lobster на **тот же хост**, что работает OpenClaw Gateway (см. [репозиторий Lobster](https://github.com/openclaw/lobster)), и убедитесь, что `lobster` находится в `PATH`. Если вы хотите использовать пользовательское местоположение бинарного файла, передайте **абсолютный** `lobsterPath` в вызове инструмента.

## Включите инструмент

Lobster — это **опциональный** инструмент плагина (не включен по умолчанию).

Рекомендуется (аддитивно, безопасно):

```json
{
  "tools": {
    "alsoAllow": ["lobster"]
  }
}
```

Или для каждого агента:

```json
{
  "agents": {
    "list": [
      {
        "id": "main",
        "tools": {
          "alsoAllow": ["lobster"]
        }
      }
    ]
  }
}
```

Избегайте использования `tools.allow: ["lobster"]`, если вы не намерены работать в ограничительном режиме списка разрешений.

Примечание: списки разрешений opt-in для опциональных плагинов. Если ваш список разрешений называет только инструменты плагинов (такие как `lobster`), OpenClaw сохраняет основные инструменты включенными. Чтобы ограничить основные инструменты, также включите основные инструменты или группы, которые вы хотите, в список разрешений.

## Пример: Сортировка email

Без Lobster:
```
Пользователь: "Check my email and draft replies"
→ openclaw вызывает gmail.list
→ LLM суммирует
→ Пользователь: "draft replies to #2 and #5"
→ LLM черновит
→ Пользователь: "send #2"
→ openclaw вызывает gmail.send
(повторяется ежедневно, нет памяти о том, что было отсортировано)
```

С Lobster:
```json
{
  "action": "run",
  "pipeline": "email.triage --limit 20",
  "timeoutMs": 30000
}
```

Возвращает JSON конверт (сокращенный):
```json
{
  "ok": true,
  "status": "needs_approval",
  "output": [{ "summary": "5 need replies, 2 need action" }],
  "requiresApproval": {
    "type": "approval_request",
    "prompt": "Send 2 draft replies?",
    "items": [],
    "resumeToken": "..."
  }
}
```

Пользователь одобряет → возобновить:
```json
{
  "action": "resume",
  "token": "<resumeToken>",
  "approve": true
}
```

Один рабочий процесс. Детерминированный. Безопасный.

## Параметры инструмента

### `run`

Запустить конвейер в режиме инструмента.

```json
{
  "action": "run",
  "pipeline": "gog.gmail.search --query 'newer_than:1d' | email.triage",
  "cwd": "/path/to/workspace",
  "timeoutMs": 30000,
  "maxStdoutBytes": 512000
}
```

Запустить файл рабочего процесса с аргументами:

```json
{
  "action": "run",
  "pipeline": "/path/to/inbox-triage.lobster",
  "argsJson": "{\"tag\":\"family\"}"
}
```

### `resume`

Продолжить остановленный рабочий процесс после одобрения.

```json
{
  "action": "resume",
  "token": "<resumeToken>",
  "approve": true
}
```

### Опциональные входы

- `lobsterPath`: Абсолютный путь к бинарному файлу Lobster (опустите, чтобы использовать `PATH`).
- `cwd`: Рабочий каталог для конвейера (по умолчанию текущий рабочий каталог процесса).
- `timeoutMs`: Убить подпроцесс, если он превышает эту длительность (по умолчанию: 20000).
- `maxStdoutBytes`: Убить подпроцесс, если stdout превышает этот размер (по умолчанию: 512000).
- `argsJson`: JSON строка, переданная в `lobster run --args-json` (только файлы рабочих процессов).

## Конверт вывода

Lobster возвращает JSON конверт с одним из трех статусов:

- `ok` → завершено успешно
- `needs_approval` → приостановлено; `requiresApproval.resumeToken` требуется для возобновления
- `cancelled` → явно отказано или отменено

Инструмент отображает конверт как в `content` (красивый JSON), так и в `details` (сырой объект).

## Одобрения

Если присутствует `requiresApproval`, проверьте подсказку и решите:

- `approve: true` → возобновить и продолжить побочные эффекты
- `approve: false` → отменить и финализировать рабочий процесс

Используйте `approve --preview-from-stdin --limit N` для прикрепления JSON предпросмотра к запросам одобрения без пользовательского клея jq/heredoc. Токены возобновления теперь компактны: Lobster хранит состояние возобновления рабочего процесса в своем каталоге состояния и возвращает небольшой токен-ключ.

## OpenProse

OpenProse хорошо сочетается с Lobster: используйте `/prose` для оркестрации подготовки с несколькими агентами, затем запустите конвейер Lobster для детерминированных одобрений. Если программе Prose нужен Lobster, разрешите инструмент `lobster` для подагентов через `tools.subagents.tools`. См. [OpenProse](/prose).

## Безопасность

- **Только локальный подпроцесс** — никаких сетевых вызовов от самого плагина.
- **Нет секретов** — Lobster не управляет OAuth; он вызывает инструменты OpenClaw, которые делают это.
- **Осведомленность об изолированной среде** — отключен, когда контекст инструмента изолирован.
- **Закален** — `lobsterPath` должен быть абсолютным, если указан; применяются тайм-ауты и ограничения вывода.

## Устранение проблем

- **`lobster subprocess timed out`** → увеличьте `timeoutMs`, или разделите длинный конвейер.
- **`lobster output exceeded maxStdoutBytes`** → увеличьте `maxStdoutBytes` или уменьшите размер вывода.
- **`lobster returned invalid JSON`** → убедитесь, что конвейер работает в режиме инструмента и выводит только JSON.
- **`lobster failed (code …)`** → запустите тот же конвейер в терминале для проверки stderr.

## Узнать больше

- [Плагины](/plugin)
- [Авторство инструментов плагинов](/plugins/agent-tools)

## Пример использования: рабочие процессы сообщества

Один публичный пример: CLI "второго мозга" + конвейеры Lobster, которые управляют тремя хранилищами Markdown (личное, партнера, общее). CLI выдает JSON для статистики, списков входящих и устаревших сканирований; Lobster связывает эти команды в рабочие процессы, такие как `weekly-review`, `inbox-triage`, `memory-consolidation` и `shared-task-sync`, каждый со шлюзами одобрения. ИИ обрабатывает суждение (категоризация), когда доступно, и возвращается к детерминированным правилам, когда нет.

- Тред: https://x.com/plattenschieber/status/2014508656335770033
- Репозиторий: https://github.com/bloomedai/brain-cli
