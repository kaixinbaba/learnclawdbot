---
summary: "Поток сообщений, сессии, очереди и видимость рассуждений"
read_when:
  - Объяснение того, как входящие сообщения становятся ответами
  - Уточнение сессий, режимов очереди или поведения потоковой передачи
  - Документирование видимости рассуждений и последствий использования
---
# Сообщения

Эта страница связывает воедино то, как OpenClaw обрабатывает входящие сообщения, сессии, очереди,
потоковую передачу и видимость рассуждений.

## Поток сообщений (высокий уровень)

```
Входящее сообщение
  -> маршрутизация/привязки -> ключ сессии
  -> очередь (если выполняется запуск)
  -> запуск агента (потоковая передача + инструменты)
  -> исходящие ответы (ограничения канала + разделение на части)
```

Ключевые настройки находятся в конфигурации:
- `messages.*` для префиксов, очередей и группового поведения.
- `agents.defaults.*` для потоковой передачи блоков и разделения на части по умолчанию.
- Переопределения каналов (`channels.whatsapp.*`, `channels.telegram.*` и т.д.) для ограничений и переключателей потоковой передачи.

См. [Configuration](/gateway/configuration) для полной схемы.

## Дедупликация входящих сообщений

Каналы могут повторно доставлять одно и то же сообщение после переподключения. OpenClaw хранит
краткосрочный кэш с ключом канал/аккаунт/peer/сессия/id сообщения, чтобы дублирующиеся
доставки не запускали еще один запуск агента.

## Дебаунсинг входящих сообщений

Быстрые последовательные сообщения от **одного отправителя** могут быть объединены в один
ход агента через `messages.inbound`. Дебаунсинг ограничен по каналу + беседе
и использует самое последнее сообщение для ответа по треду/ID.

Конфигурация (глобальное значение по умолчанию + переопределения по каналам):
```json5
{
  messages: {
    inbound: {
      debounceMs: 2000,
      byChannel: {
        whatsapp: 5000,
        slack: 1500,
        discord: 1500
      }
    }
  }
}
```

Примечания:
- Дебаунсинг применяется к **текстовым** сообщениям; медиа/вложения сбрасываются немедленно.
- Контрольные команды обходят дебаунсинг, поэтому они остаются автономными.

## Сессии и устройства

Сессии принадлежат gateway, а не клиентам.
- Прямые чаты сворачиваются в ключ основной сессии агента.
- Группы/каналы получают свои собственные ключи сессий.
- Хранилище сессий и транскрипты находятся на хосте gateway.

Несколько устройств/каналов могут отображаться на одну сессию, но история не полностью
синхронизируется обратно на каждый клиент. Рекомендация: используйте одно основное устройство для длинных
бесед, чтобы избежать расходящегося контекста. Control UI и TUI всегда показывают
транскрипт сессии, поддерживаемый gateway, поэтому они являются источником истины.

Детали: [Управление сессиями](/concepts/session).

## Тела входящих сообщений и контекст истории

OpenClaw разделяет **тело подсказки** и **тело команды**:
- `Body`: текст подсказки, отправляемый агенту. Может включать конверты каналов и
  необязательные обертки истории.
- `CommandBody`: необработанный текст пользователя для разбора директив/команд.
- `RawBody`: устаревший псевдоним для `CommandBody` (сохранен для совместимости).

Когда канал предоставляет историю, он использует общую обертку:
- `[Chat messages since your last reply - for context]`
- `[Current message - respond to this]`

Для **не прямых чатов** (группы/каналы/комнаты) **тело текущего сообщения** имеет префикс с
меткой отправителя (тот же стиль, что используется для записей истории). Это сохраняет реальное время и очереди/историю
сообщений последовательными в подсказке агента.

Буферы истории **только ожидающие**: они включают групповые сообщения, которые *не*
запускали выполнение (например, сообщения с ограниченным упоминанием) и **исключают** сообщения,
уже находящиеся в транскрипте сессии.

Удаление директив применяется только к разделу **текущего сообщения**, поэтому история
остается нетронутой. Каналы, которые оборачивают историю, должны устанавливать `CommandBody` (или
`RawBody`) в исходный текст сообщения и сохранять `Body` как объединенную подсказку.
Буферы истории настраиваются через `messages.groupChat.historyLimit` (глобальное
значение по умолчанию) и переопределения по каналам, такие как `channels.slack.historyLimit` или
`channels.telegram.accounts.<id>.historyLimit` (установите `0`, чтобы отключить).

## Очереди и последующие действия

Если выполнение уже активно, входящие сообщения могут быть поставлены в очередь, направлены в
текущее выполнение или собраны для последующего хода.

- Настройте через `messages.queue` (и `messages.queue.byChannel`).
- Режимы: `interrupt`, `steer`, `followup`, `collect`, плюс варианты с backlog.

Детали: [Очередь](/concepts/queue).

## Потоковая передача, разделение на части и пакетирование

Потоковая передача блоков отправляет частичные ответы по мере того, как модель производит текстовые блоки.
Разделение на части учитывает текстовые ограничения канала и избегает разделения огражденного кода.

Ключевые настройки:
- `agents.defaults.blockStreamingDefault` (`on|off`, по умолчанию off)
- `agents.defaults.blockStreamingBreak` (`text_end|message_end`)
- `agents.defaults.blockStreamingChunk` (`minChars|maxChars|breakPreference`)
- `agents.defaults.blockStreamingCoalesce` (пакетирование на основе простоя)
- `agents.defaults.humanDelay` (пауза, похожая на человеческую, между блочными ответами)
- Переопределения каналов: `*.blockStreaming` и `*.blockStreamingCoalesce` (каналы, отличные от Telegram, требуют явного `*.blockStreaming: true`)

Детали: [Потоковая передача + разделение](/concepts/streaming).

## Видимость рассуждений и токены

OpenClaw может показывать или скрывать рассуждения модели:
- `/reasoning on|off|stream` контролирует видимость.
- Содержимое рассуждений все еще учитывается в использовании токенов, когда оно производится моделью.
- Telegram поддерживает поток рассуждений в пузырь черновика.

Детали: [Директивы мышления + рассуждений](/tools/thinking) и [Использование токенов](/token-use).

## Префиксы, треды и ответы

Форматирование исходящих сообщений централизовано в `messages`:
- `messages.responsePrefix` (исходящий префикс) и `channels.whatsapp.messagePrefix` (входящий префикс WhatsApp)
- Ответ по треду через `replyToMode` и значения по умолчанию для каждого канала

Детали: [Configuration](/gateway/configuration#messages) и документация по каналам.
