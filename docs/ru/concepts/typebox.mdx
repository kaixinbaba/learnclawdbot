---
summary: "Схемы TypeBox как единый источник истины для протокола шлюза"
read_when:
  - Updating protocol schemas or codegen
---
# TypeBox как источник истины протокола

Последнее обновление: 2026-01-10

TypeBox — это TypeScript-ориентированная библиотека схем. Мы используем её для определения **протокола
WebSocket шлюза** (рукопожатие, запрос/ответ, серверные события). Эти схемы управляют **валидацией во время выполнения**, **экспортом JSON Schema** и **генерацией кода Swift** для
приложения macOS. Один источник истины; всё остальное генерируется.

Если вам нужен более высокоуровневый контекст протокола, начните с
[Gateway architecture](/concepts/architecture).

## Ментальная модель (30 секунд)

Каждое сообщение Gateway WS — один из трёх фреймов:

- **Запрос**: `{ type: "req", id, method, params }`
- **Ответ**: `{ type: "res", id, ok, payload | error }`
- **Событие**: `{ type: "event", event, payload, seq?, stateVersion? }`

Первый фрейм **должен** быть запросом `connect`. После этого клиенты могут вызывать
методы (например, `health`, `send`, `chat.send`) и подписываться на события (например,
`presence`, `tick`, `agent`).

Поток подключения (минимальный):

```
Клиент                    Шлюз
  |---- req:connect -------->|
  |<---- res:hello-ok --------|
  |<---- event:tick ----------|
  |---- req:health ---------->|
  |<---- res:health ----------|
```

Общие методы + события:

| Категория | Примеры | Примечания |
| --- | --- | --- |
| Ядро | `connect`, `health`, `status` | `connect` должен быть первым |
| Обмен сообщениями | `send`, `poll`, `agent`, `agent.wait` | побочные эффекты требуют `idempotencyKey` |
| Чат | `chat.history`, `chat.send`, `chat.abort`, `chat.inject` | WebChat использует эти |
| Сессии | `sessions.list`, `sessions.patch`, `sessions.delete` | администрирование сессий |
| Узлы | `node.list`, `node.invoke`, `node.pair.*` | Gateway WS + действия узлов |
| События | `tick`, `presence`, `agent`, `chat`, `health`, `shutdown` | серверный push |

Авторитетный список находится в `src/gateway/server.ts` (`METHODS`, `EVENTS`).

## Где находятся схемы

- Источник: `src/gateway/protocol/schema.ts`
- Валидаторы времени выполнения (AJV): `src/gateway/protocol/index.ts`
- Рукопожатие сервера + диспетчер методов: `src/gateway/server.ts`
- Клиент узла: `src/gateway/client.ts`
- Сгенерированная JSON Schema: `dist/protocol.schema.json`
- Сгенерированные модели Swift: `apps/macos/Sources/OpenClawProtocol/GatewayModels.swift`

## Текущий конвейер

- `pnpm protocol:gen`
  - записывает JSON Schema (draft‑07) в `dist/protocol.schema.json`
- `pnpm protocol:gen:swift`
  - генерирует модели шлюза Swift
- `pnpm protocol:check`
  - запускает оба генератора и проверяет, что вывод закоммичен

## Как схемы используются во время выполнения

- **Сторона сервера**: каждый входящий фрейм валидируется с AJV. Рукопожатие только
  принимает запрос `connect`, чьи параметры соответствуют `ConnectParams`.
- **Сторона клиента**: JS клиент валидирует фреймы событий и ответов перед
  их использованием.
- **Поверхность методов**: Шлюз рекламирует поддерживаемые `методы` и
  `события` в `hello-ok`.

## Примеры фреймов

Connect (первое сообщение):

```json
{
  "type": "req",
  "id": "c1",
  "method": "connect",
  "params": {
    "minProtocol": 2,
    "maxProtocol": 2,
    "client": {
      "id": "openclaw-macos",
      "displayName": "macos",
      "version": "1.0.0",
      "platform": "macos 15.1",
      "mode": "ui",
      "instanceId": "A1B2"
    }
  }
}
```

Ответ Hello-ok:

```json
{
  "type": "res",
  "id": "c1",
  "ok": true,
  "payload": {
    "type": "hello-ok",
    "protocol": 2,
    "server": { "version": "dev", "connId": "ws-1" },
    "features": { "methods": ["health"], "events": ["tick"] },
    "snapshot": { "presence": [], "health": {}, "stateVersion": { "presence": 0, "health": 0 }, "uptimeMs": 0 },
    "policy": { "maxPayload": 1048576, "maxBufferedBytes": 1048576, "tickIntervalMs": 30000 }
  }
}
```

Запрос + ответ:

```json
{ "type": "req", "id": "r1", "method": "health" }
```

```json
{ "type": "res", "id": "r1", "ok": true, "payload": { "ok": true } }
```

Событие:

```json
{ "type": "event", "event": "tick", "payload": { "ts": 1730000000 }, "seq": 12 }
```

## Минимальный клиент (Node.js)

Наименьший полезный поток: connect + health.

```ts
import { WebSocket } from "ws";

const ws = new WebSocket("ws://127.0.0.1:18789");

ws.on("open", () => {
  ws.send(JSON.stringify({
    type: "req",
    id: "c1",
    method: "connect",
    params: {
      minProtocol: 3,
      maxProtocol: 3,
      client: {
        id: "cli",
        displayName: "example",
        version: "dev",
        platform: "node",
        mode: "cli"
      }
    }
  }));
});

ws.on("message", (data) => {
  const msg = JSON.parse(String(data));
  if (msg.type === "res" && msg.id === "c1" && msg.ok) {
    ws.send(JSON.stringify({ type: "req", id: "h1", method: "health" }));
  }
  if (msg.type === "res" && msg.id === "h1") {
    console.log("health:", msg.payload);
    ws.close();
  }
});
```

## Рабочий пример: добавить метод от начала до конца

Пример: добавить новый запрос `system.echo`, который возвращает `{ ok: true, text }`.

1) **Схема (источник истины)**

Добавить в `src/gateway/protocol/schema.ts`:

```ts
export const SystemEchoParamsSchema = Type.Object(
  { text: NonEmptyString },
  { additionalProperties: false },
);

export const SystemEchoResultSchema = Type.Object(
  { ok: Type.Boolean(), text: NonEmptyString },
  { additionalProperties: false },
);
```

Добавить оба в `ProtocolSchemas` и экспортировать типы:

```ts
  SystemEchoParams: SystemEchoParamsSchema,
  SystemEchoResult: SystemEchoResultSchema,
```

```ts
export type SystemEchoParams = Static<typeof SystemEchoParamsSchema>;
export type SystemEchoResult = Static<typeof SystemEchoResultSchema>;
```

2) **Валидация**

В `src/gateway/protocol/index.ts`, экспортировать валидатор AJV:

```ts
export const validateSystemEchoParams =
  ajv.compile<SystemEchoParams>(SystemEchoParamsSchema);
```

3) **Поведение сервера**

Добавить обработчик в `src/gateway/server-methods/system.ts`:

```ts
export const systemHandlers: GatewayRequestHandlers = {
  "system.echo": ({ params, respond }) => {
    const text = String(params.text ?? "");
    respond(true, { ok: true, text });
  },
};
```

Зарегистрировать его в `src/gateway/server-methods.ts` (уже объединяет `systemHandlers`),
затем добавить `"system.echo"` в `METHODS` в `src/gateway/server.ts`.

4) **Регенерировать**

```bash
pnpm protocol:check
```

5) **Тесты + документы**

Добавить серверный тест в `src/gateway/server.*.test.ts` и отметить метод в документах.

## Поведение генерации кода Swift

Генератор Swift выводит:

- Enum `GatewayFrame` с кейсами `req`, `res`, `event` и `unknown`
- Строго типизированные структуры/enums полезных нагрузок
- Значения `ErrorCode` и `GATEWAY_PROTOCOL_VERSION`

Неизвестные типы фреймов сохраняются как необработанные полезные нагрузки для прямой совместимости.

## Версионирование + совместимость

- `PROTOCOL_VERSION` находится в `src/gateway/protocol/schema.ts`.
- Клиенты отправляют `minProtocol` + `maxProtocol`; сервер отклоняет несоответствия.
- Модели Swift сохраняют неизвестные типы фреймов, чтобы избежать поломки старых клиентов.

## Шаблоны схем и соглашения

- Большинство объектов используют `additionalProperties: false` для строгих полезных нагрузок.
- `NonEmptyString` — умолчание для ID и имён методов/событий.
- Верхнеуровневый `GatewayFrame` использует **дискриминатор** на `type`.
- Методы с побочными эффектами обычно требуют `idempotencyKey` в параметрах
  (пример: `send`, `poll`, `agent`, `chat.send`).

## Живая схема JSON

Сгенерированная JSON Schema находится в репозитории в `dist/protocol.schema.json`.
Опубликованный необработанный файл обычно доступен по адресу:

- https://raw.githubusercontent.com/openclaw/openclaw/main/dist/protocol.schema.json

## Когда вы изменяете схемы

1) Обновите схемы TypeBox.
2) Запустите `pnpm protocol:check`.
3) Закоммитьте регенерированную схему + модели Swift.
