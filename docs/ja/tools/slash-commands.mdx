---
summary: "スラッシュコマンド: テキスト vs ネイティブ、設定、サポートされているコマンド"
read_when:
  - チャットコマンドを使用または設定する場合
  - コマンドルーティングまたは権限をデバッグする場合
---
# スラッシュコマンド

コマンドはGatewayによって処理されます。ほとんどのコマンドは、`/`で始まる**スタンドアロン**メッセージとして送信する必要があります。
ホスト専用のbashチャットコマンドは`! <cmd>`を使用します（`/bash <cmd>`がエイリアスです）。

関連する2つのシステムがあります:

- **コマンド**: スタンドアロン`/...`メッセージ。
- **ディレクティブ**: `/think`、`/verbose`、`/reasoning`、`/elevated`、`/exec`、`/model`、`/queue`。
  - ディレクティブは、モデルがそれを見る前にメッセージから削除されます。
  - 通常のチャットメッセージ（ディレクティブのみではない）では、「インラインヒント」として扱われ、セッション設定を**永続化しません**。
  - ディレクティブのみのメッセージ（メッセージにディレクティブのみが含まれる）では、セッションに永続化され、確認応答で返信します。
  - ディレクティブは、**承認された送信者**に対してのみ適用されます（チャネル許可リスト/ペアリング + `commands.useAccessGroups`）。
    承認されていない送信者は、ディレクティブがプレーンテキストとして扱われることを確認します。

また、いくつかの**インラインショートカット**（許可リスト/承認された送信者のみ）もあります: `/help`、`/commands`、`/status`、`/whoami`（`/id`）。
これらは即座に実行され、モデルがメッセージを見る前に削除され、残りのテキストは通常のフローを継続します。

## 設定

```json5
{
  commands: {
    native: "auto",
    nativeSkills: "auto",
    text: true,
    bash: false,
    bashForegroundMs: 2000,
    config: false,
    debug: false,
    restart: false,
    useAccessGroups: true
  }
}
```

- `commands.text`（デフォルト`true`）は、チャットメッセージ内の`/...`の解析を有効にします。
  - ネイティブコマンドのないサーフェス（WhatsApp/WebChat/Signal/iMessage/Google Chat/MS Teams）では、これを`false`に設定してもテキストコマンドは引き続き機能します。
- `commands.native`（デフォルト`"auto"`）は、ネイティブコマンドを登録します。
  - Auto: Discord/Telegramでオン。Slackではオフ（スラッシュコマンドを追加するまで）。ネイティブサポートのないプロバイダーでは無視されます。
  - プロバイダーごとにオーバーライドするには、`channels.discord.commands.native`、`channels.telegram.commands.native`、または`channels.slack.commands.native`を設定します（boolまたは`"auto"`）。
  - `false`は、起動時にDiscord/Telegramで以前に登録されたコマンドをクリアします。SlackコマンドはSlackアプリで管理され、自動的には削除されません。
- `commands.nativeSkills`（デフォルト`"auto"`）は、サポートされている場合に**スキル**コマンドをネイティブに登録します。
  - Auto: Discord/Telegramでオン。Slackではオフ（Slackはスキルごとにスラッシュコマンドを作成する必要があります）。
  - プロバイダーごとにオーバーライドするには、`channels.discord.commands.nativeSkills`、`channels.telegram.commands.nativeSkills`、または`channels.slack.commands.nativeSkills`を設定します（boolまたは`"auto"`）。
- `commands.bash`（デフォルト`false`）は、ホストシェルコマンドを実行するために`! <cmd>`を有効にします（`/bash <cmd>`がエイリアス。`tools.elevated`許可リストが必要）。
- `commands.bashForegroundMs`（デフォルト`2000`）は、bashがバックグラウンドモードに切り替わる前に待機する時間を制御します（`0`は即座にバックグラウンド化します）。
- `commands.config`（デフォルト`false`）は`/config`を有効にします（`openclaw.json`の読み取り/書き込み）。
- `commands.debug`（デフォルト`false`）は`/debug`を有効にします（ランタイムのみのオーバーライド）。
- `commands.useAccessGroups`（デフォルト`true`）は、コマンドの許可リスト/ポリシーを強制します。

## コマンドリスト

テキスト + ネイティブ（有効な場合）:
- `/help`
- `/commands`
- `/skill <name> [input]`（名前でスキルを実行）
- `/status`（現在のステータスを表示。利用可能な場合、現在のモデルプロバイダーのプロバイダー使用状況/クォータを含む）
- `/allowlist`（許可リストエントリのリスト/追加/削除）
- `/approve <id> allow-once|allow-always|deny`（exec承認プロンプトを解決）
- `/context [list|detail|json]`（「コンテキスト」を説明。`detail`はファイルごと + ツールごと + スキルごと + システムプロンプトサイズを表示）
- `/whoami`（送信者IDを表示。エイリアス: `/id`）
- `/subagents list|stop|log|info|send`（現在のセッションのサブエージェント実行を検査、停止、ログ、またはメッセージ）
- `/config show|get|set|unset`（ディスクに設定を永続化、所有者のみ。`commands.config: true`が必要）
- `/debug show|set|unset|reset`（ランタイムオーバーライド、所有者のみ。`commands.debug: true`が必要）
- `/usage off|tokens|full|cost`（レスポンスごとの使用状況フッターまたはローカルコストサマリー）
- `/tts off|always|inbound|tagged|status|provider|limit|summary|audio`（TTSを制御。[/tts](/tts)を参照）
  - Discord: ネイティブコマンドは`/voice`です（Discordは`/tts`を予約しています）。テキスト`/tts`は引き続き機能します。
- `/stop`
- `/restart`
- `/dock-telegram`（エイリアス: `/dock_telegram`）（返信をTelegramに切り替え）
- `/dock-discord`（エイリアス: `/dock_discord`）（返信をDiscordに切り替え）
- `/dock-slack`（エイリアス: `/dock_slack`）（返信をSlackに切り替え）
- `/activation mention|always`（グループのみ）
- `/send on|off|inherit`（所有者のみ）
- `/reset`または`/new [model]`（オプションのモデルヒント。残りはパススルーされます）
- `/think <off|minimal|low|medium|high|xhigh>`（モデル/プロバイダーによる動的選択。エイリアス: `/thinking`、`/t`）
- `/verbose on|full|off`（エイリアス: `/v`）
- `/reasoning on|off|stream`（エイリアス: `/reason`。オンの場合、`Reasoning:`でプレフィックスされた別のメッセージを送信します。`stream` = Telegramドラフトのみ）
- `/elevated on|off|ask|full`（エイリアス: `/elev`。`full`はexec承認をスキップします）
- `/exec host=<sandbox|gateway|node> security=<deny|allowlist|full> ask=<off|on-miss|always> node=<id>`（現在の状態を表示するには`/exec`を送信）
- `/model <name>`（エイリアス: `/models`。または`agents.defaults.models.*.alias`からの`/<alias>`）
- `/queue <mode>`（`debounce:2s cap:25 drop:summarize`などのオプションを追加。現在の設定を確認するには`/queue`を送信）
- `/bash <command>`（ホストのみ。`! <command>`のエイリアス。`commands.bash: true` + `tools.elevated`許可リストが必要）

テキストのみ:
- `/compact [instructions]`（[/concepts/compaction](/concepts/compaction)を参照）
- `! <command>`（ホストのみ。一度に1つ。長時間実行ジョブには`!poll` + `!stop`を使用）
- `!poll`（出力/ステータスをチェック。オプションの`sessionId`を受け入れます。`/bash poll`も機能します）
- `!stop`（実行中のbashジョブを停止。オプションの`sessionId`を受け入れます。`/bash stop`も機能します）

注意事項:
- コマンドは、コマンドと引数の間にオプションの`:`を受け入れます（例: `/think: high`、`/send: on`、`/help:`）。
- `/new <model>`は、モデルエイリアス、`provider/model`、またはプロバイダー名（ファジーマッチ）を受け入れます。一致しない場合、テキストはメッセージ本文として扱われます。
- 完全なプロバイダー使用状況の内訳については、`openclaw status --usage`を使用してください。
- `/allowlist add|remove`には`commands.config=true`が必要で、チャネル`configWrites`を尊重します。
- `/usage`は、レスポンスごとの使用状況フッターを制御します。`/usage cost`は、OpenClawセッションログからローカルコストサマリーを出力します。
- `/restart`はデフォルトで無効になっています。有効にするには`commands.restart: true`を設定してください。
- `/verbose`はデバッグと追加の可視性のためのものです。通常の使用では**オフ**のままにしてください。
- `/reasoning`（および`/verbose`）は、グループ設定でリスクがあります: 公開する意図のない内部推論またはツール出力を明らかにする可能性があります。特にグループチャットでは、オフのままにすることを優先してください。
- **高速パス:** 許可リスト送信者からのコマンドのみのメッセージは、即座に処理されます（キュー + モデルをバイパス）。
- **グループメンションゲーティング:** 許可リスト送信者からのコマンドのみのメッセージは、メンション要件をバイパスします。
- **インラインショートカット（許可リスト送信者のみ）:** 特定のコマンドは、通常のメッセージに埋め込まれている場合にも機能し、モデルが残りのテキストを見る前に削除されます。
  - 例: `hey /status`はステータス返信をトリガーし、残りのテキストは通常のフローを継続します。
- 現在: `/help`、`/commands`、`/status`、`/whoami`（`/id`）。
- 承認されていないコマンドのみのメッセージは、静かに無視され、インライン`/...`トークンはプレーンテキストとして扱われます。
- **スキルコマンド:** `user-invocable`スキルはスラッシュコマンドとして公開されます。名前は`a-z0-9_`に正規化されます（最大32文字）。衝突は数値サフィックスを取得します（例: `_2`）。
  - `/skill <name> [input]`は名前でスキルを実行します（ネイティブコマンドの制限がスキルごとのコマンドを妨げる場合に便利）。
  - デフォルトでは、スキルコマンドは通常のリクエストとしてモデルに転送されます。
  - スキルは、オプションで`command-dispatch: tool`を宣言して、コマンドを直接ツールにルーティングできます（決定的、モデルなし）。
  - 例: `/prose`（OpenProseプラグイン） — [OpenProse](/prose)を参照。
- **ネイティブコマンド引数:** Discordは、動的オプションにオートコンプリートを使用します（必要な引数を省略した場合はボタンメニュー）。TelegramとSlackは、コマンドが選択肢をサポートし、引数を省略した場合にボタンメニューを表示します。

## 使用状況サーフェス（どこに何が表示されるか）

- **プロバイダー使用状況/クォータ**（例: 「Claude 80% left」）は、使用状況追跡が有効になっている場合、現在のモデルプロバイダーの`/status`に表示されます。
- **レスポンスごとのトークン/コスト**は、`/usage off|tokens|full`で制御されます（通常の返信に追加されます）。
- `/model status`は、**モデル/認証/エンドポイント**に関するものであり、使用状況ではありません。

## モデル選択（`/model`）

`/model`は、ディレクティブとして実装されています。

例:

```
/model
/model list
/model 3
/model openai/gpt-5.2
/model opus@anthropic:default
/model status
```

注意事項:
- `/model`と`/model list`は、コンパクトで番号付きのピッカー（モデルファミリー + 利用可能なプロバイダー）を表示します。
- `/model <#>`は、そのピッカーから選択します（可能な場合、現在のプロバイダーを優先します）。
- `/model status`は、設定されたプロバイダーエンドポイント（`baseUrl`）とAPIモード（`api`）を含む詳細ビューを表示します（利用可能な場合）。

## デバッグオーバーライド

`/debug`は、**ランタイムのみ**の設定オーバーライド（メモリ、ディスクではない）を設定できます。所有者のみ。デフォルトで無効。`commands.debug: true`で有効にします。

例:

```
/debug show
/debug set messages.responsePrefix="[openclaw]"
/debug set channels.whatsapp.allowFrom=["+1555","+4477"]
/debug unset messages.responsePrefix
/debug reset
```

注意事項:
- オーバーライドは、新しい設定読み取りに即座に適用されますが、`openclaw.json`に**書き込まれません**。
- すべてのオーバーライドをクリアしてディスク上の設定に戻るには、`/debug reset`を使用してください。

## 設定の更新

`/config`は、ディスク上の設定（`openclaw.json`）に書き込みます。所有者のみ。デフォルトで無効。`commands.config: true`で有効にします。

例:

```
/config show
/config show messages.responsePrefix
/config get messages.responsePrefix
/config set messages.responsePrefix="[openclaw]"
/config unset messages.responsePrefix
```

注意事項:
- 設定は書き込み前に検証されます。無効な変更は拒否されます。
- `/config`の更新は再起動後も持続します。

## サーフェスの注意事項

- **テキストコマンド**は、通常のチャットセッションで実行されます（DMは`main`を共有し、グループには独自のセッションがあります）。
- **ネイティブコマンド**は、分離されたセッションを使用します:
  - Discord: `agent:<agentId>:discord:slash:<userId>`
  - Slack: `agent:<agentId>:slack:slash:<userId>`（プレフィックスは`channels.slack.slashCommand.sessionPrefix`で設定可能）
  - Telegram: `telegram:slash:<userId>`（`CommandTargetSessionKey`を介してチャットセッションをターゲット）
- **`/stop`**は、アクティブなチャットセッションをターゲットにして、現在の実行を中止できます。
- **Slack:** 単一の`/openclaw`スタイルのコマンドには、`channels.slack.slashCommand`が引き続きサポートされています。`commands.native`を有効にする場合、組み込みコマンドごとに1つのSlackスラッシュコマンドを作成する必要があります（`/help`と同じ名前）。Slackのコマンド引数メニューは、エフェメラルBlock Kitボタンとして配信されます。
