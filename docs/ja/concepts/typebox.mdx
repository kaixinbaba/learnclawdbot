---
summary: "ゲートウェイプロトコルの唯一の信頼できる情報源としてのTypeBoxスキーマ"
read_when:
  - プロトコルスキーマまたはコード生成を更新する場合
---
# プロトコルの信頼できる情報源としてのTypeBox

最終更新：2026-01-10

TypeBoxはTypeScriptファーストのスキーマライブラリです。これを使用して**Gateway
WebSocketプロトコル**（ハンドシェイク、リクエスト/レスポンス、サーバーイベント）を定義します。これらのスキーマは**ランタイム検証**、**JSON Schemaエクスポート**、およびmacOSアプリ用の**Swiftコード生成**を駆動します。唯一の信頼できる情報源。他のすべては生成されます。

より高レベルのプロトコルコンテキストが必要な場合は、[Gatewayアーキテクチャ](/concepts/architecture)から始めてください。

## メンタルモデル（30秒）

すべてのGateway WSメッセージは3つのフレームのいずれかです：

- **Request**: `{ type: "req", id, method, params }`
- **Response**: `{ type: "res", id, ok, payload | error }`
- **Event**: `{ type: "event", event, payload, seq?, stateVersion? }`

最初のフレームは`connect`リクエストで**なければなりません**。その後、クライアントはメソッド（例：`health`、`send`、`chat.send`）を呼び出し、イベント（例：`presence`、`tick`、`agent`）にサブスクライブできます。

接続フロー（最小限）：

```
Client                    Gateway
  |---- req:connect -------->|
  |<---- res:hello-ok --------|
  |<---- event:tick ----------|
  |---- req:health ---------->|
  |<---- res:health ----------|
```

一般的なメソッド + イベント：

| カテゴリ | 例 | 注意 |
| --- | --- | --- |
| Core | `connect`, `health`, `status` | `connect`が最初でなければならない |
| Messaging | `send`, `poll`, `agent`, `agent.wait` | 副作用には`idempotencyKey`が必要 |
| Chat | `chat.history`, `chat.send`, `chat.abort`, `chat.inject` | WebChatがこれらを使用 |
| Sessions | `sessions.list`, `sessions.patch`, `sessions.delete` | セッション管理 |
| Nodes | `node.list`, `node.invoke`, `node.pair.*` | Gateway WS + ノードアクション |
| Events | `tick`, `presence`, `agent`, `chat`, `health`, `shutdown` | サーバープッシュ |

権威あるリストは`src/gateway/server.ts` (`METHODS`, `EVENTS`)にあります。

## スキーマの場所

- ソース: `src/gateway/protocol/schema.ts`
- ランタイムバリデーター（AJV）: `src/gateway/protocol/index.ts`
- サーバーハンドシェイク + メソッドディスパッチ: `src/gateway/server.ts`
- ノードクライアント: `src/gateway/client.ts`
- 生成されたJSON Schema: `dist/protocol.schema.json`
- 生成されたSwiftモデル: `apps/macos/Sources/OpenClawProtocol/GatewayModels.swift`

## 現在のパイプライン

- `pnpm protocol:gen`
  - JSON Schema（draft‑07）を`dist/protocol.schema.json`に書き込み
- `pnpm protocol:gen:swift`
  - Swiftゲートウェイモデルを生成
- `pnpm protocol:check`
  - 両方のジェネレーターを実行し、出力がコミットされていることを確認

## ランタイムでのスキーマの使用方法

- **サーバー側**: すべての受信フレームはAJVで検証されます。ハンドシェイクは、パラメータが`ConnectParams`と一致する`connect`リクエストのみを受け入れます。
- **クライアント側**: JSクライアントはイベントとレスポンスフレームを使用する前に検証します。
- **メソッドサーフェス**: Gatewayは`hello-ok`でサポートされている`methods`と`events`をアドバタイズします。

## フレームの例

接続（最初のメッセージ）：

```json
{
  "type": "req",
  "id": "c1",
  "method": "connect",
  "params": {
    "minProtocol": 2,
    "maxProtocol": 2,
    "client": {
      "id": "openclaw-macos",
      "displayName": "macos",
      "version": "1.0.0",
      "platform": "macos 15.1",
      "mode": "ui",
      "instanceId": "A1B2"
    }
  }
}
```

Hello-okレスポンス：

```json
{
  "type": "res",
  "id": "c1",
  "ok": true,
  "payload": {
    "type": "hello-ok",
    "protocol": 2,
    "server": { "version": "dev", "connId": "ws-1" },
    "features": { "methods": ["health"], "events": ["tick"] },
    "snapshot": { "presence": [], "health": {}, "stateVersion": { "presence": 0, "health": 0 }, "uptimeMs": 0 },
    "policy": { "maxPayload": 1048576, "maxBufferedBytes": 1048576, "tickIntervalMs": 30000 }
  }
}
```

リクエスト + レスポンス：

```json
{ "type": "req", "id": "r1", "method": "health" }
```

```json
{ "type": "res", "id": "r1", "ok": true, "payload": { "ok": true } }
```

イベント：

```json
{ "type": "event", "event": "tick", "payload": { "ts": 1730000000 }, "seq": 12 }
```

## 最小クライアント（Node.js）

最小限の有用なフロー：接続 + ヘルス。

```ts
import { WebSocket } from "ws";

const ws = new WebSocket("ws://127.0.0.1:18789");

ws.on("open", () => {
  ws.send(JSON.stringify({
    type: "req",
    id: "c1",
    method: "connect",
    params: {
      minProtocol: 3,
      maxProtocol: 3,
      client: {
        id: "cli",
        displayName: "example",
        version: "dev",
        platform: "node",
        mode: "cli"
      }
    }
  }));
});

ws.on("message", (data) => {
  const msg = JSON.parse(String(data));
  if (msg.type === "res" && msg.id === "c1" && msg.ok) {
    ws.send(JSON.stringify({ type: "req", "id": "h1", method: "health" }));
  }
  if (msg.type === "res" && msg.id === "h1") {
    console.log("health:", msg.payload);
    ws.close();
  }
});
```

## 実例：エンドツーエンドでメソッドを追加

例：`{ ok: true, text }`を返す新しい`system.echo`リクエストを追加。

1) **スキーマ（信頼できる情報源）**

`src/gateway/protocol/schema.ts`に追加：

```ts
export const SystemEchoParamsSchema = Type.Object(
  { text: NonEmptyString },
  { additionalProperties: false },
);

export const SystemEchoResultSchema = Type.Object(
  { ok: Type.Boolean(), text: NonEmptyString },
  { additionalProperties: false },
);
```

両方を`ProtocolSchemas`に追加し、型をエクスポート：

```ts
  SystemEchoParams: SystemEchoParamsSchema,
  SystemEchoResult: SystemEchoResultSchema,
```

```ts
export type SystemEchoParams = Static<typeof SystemEchoParamsSchema>;
export type SystemEchoResult = Static<typeof SystemEchoResultSchema>;
```

2) **検証**

`src/gateway/protocol/index.ts`でAJVバリデーターをエクスポート：

```ts
export const validateSystemEchoParams =
  ajv.compile<SystemEchoParams>(SystemEchoParamsSchema);
```

3) **サーバー動作**

`src/gateway/server-methods/system.ts`にハンドラーを追加：

```ts
export const systemHandlers: GatewayRequestHandlers = {
  "system.echo": ({ params, respond }) => {
    const text = String(params.text ?? "");
    respond(true, { ok: true, text });
  },
};
```

`src/gateway/server-methods.ts`に登録（すでに`systemHandlers`をマージ）し、`src/gateway/server.ts`の`METHODS`に`"system.echo"`を追加します。

4) **再生成**

```bash
pnpm protocol:check
```

5) **テスト + ドキュメント**

`src/gateway/server.*.test.ts`にサーバーテストを追加し、ドキュメントにメソッドを記載します。

## Swiftコード生成動作

Swiftジェネレーターは次を出力します：

- `req`、`res`、`event`、`unknown`ケースを持つ`GatewayFrame`列挙型
- 強く型付けされたペイロード構造体/列挙型
- `ErrorCode`値と`GATEWAY_PROTOCOL_VERSION`

未知のフレームタイプは、前方互換性のために生のペイロードとして保持されます。

## バージョニング + 互換性

- `PROTOCOL_VERSION`は`src/gateway/protocol/schema.ts`にあります。
- クライアントは`minProtocol` + `maxProtocol`を送信します。サーバーは不一致を拒否します。
- Swiftモデルは、古いクライアントの破損を避けるために未知のフレームタイプを保持します。

## スキーマパターンと慣習

- ほとんどのオブジェクトは、厳密なペイロードのために`additionalProperties: false`を使用します。
- `NonEmptyString`はIDおよびメソッド/イベント名のデフォルトです。
- トップレベルの`GatewayFrame`は`type`で**discriminator**を使用します。
- 副作用を持つメソッドは通常、パラメータに`idempotencyKey`が必要です（例：`send`、`poll`、`agent`、`chat.send`）。

## ライブスキーマJSON

生成されたJSON Schemaは`dist/protocol.schema.json`のリポジトリにあります。公開されている生ファイルは通常、次の場所で利用できます：

- https://raw.githubusercontent.com/openclaw/openclaw/main/dist/protocol.schema.json

## スキーマを変更する場合

1) TypeBoxスキーマを更新します。
2) `pnpm protocol:check`を実行します。
3) 再生成されたスキーマ + Swiftモデルをコミットします。
