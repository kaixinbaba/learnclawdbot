---
summary: "Telegramボットのサポート状況、機能、および設定"
read_when:
  - Telegram機能またはWebhookに関する作業時
---
# Telegram (Bot API)

ステータス：grammYを介したボットDM + グループで本番環境対応。デフォルトはロングポーリング。Webhookはオプション。

## クイックセットアップ（初心者向け）
1) **@BotFather**でボットを作成し、トークンをコピーします。
2) トークンを設定します：
   - 環境変数：`TELEGRAM_BOT_TOKEN=...`
   - または設定ファイル：`channels.telegram.botToken: "..."`
   - 両方設定された場合、設定ファイルが優先されます（環境変数フォールバックはデフォルトアカウントのみ）。
3) ゲートウェイを起動します。
4) DMアクセスはデフォルトでペアリング。初回コンタクト時にペアリングコードを承認してください。

最小限の設定：
```json5
{
  channels: {
    telegram: {
      enabled: true,
      botToken: "123:abc",
      dmPolicy: "pairing"
    }
  }
}
```

## これは何か
- ゲートウェイが所有するTelegram Bot APIチャネル。
- 決定論的ルーティング：返信はTelegramに戻る。モデルはチャネルを選択しません。
- DMはエージェントのメインセッションを共有し、グループは分離されます（`agent:<agentId>:telegram:group:<chatId>`）。

## セットアップ（高速パス）
### 1) ボットトークンの作成（BotFather）
1) Telegramを開き、**@BotFather**とチャットします。
2) `/newbot`を実行し、プロンプトに従います（名前 + `bot`で終わるユーザー名）。
3) トークンをコピーして安全に保管します。

オプションのBotFather設定：
- `/setjoingroups` — ボットのグループ追加の許可/拒否。
- `/setprivacy` — ボットがすべてのグループメッセージを見るかどうかを制御。

### 2) トークンの設定（環境変数または設定ファイル）
例：

```json5
{
  channels: {
    telegram: {
      enabled: true,
      botToken: "123:abc",
      dmPolicy: "pairing",
      groups: { "*": { requireMention: true } }
    }
  }
}
```

環境変数オプション：`TELEGRAM_BOT_TOKEN=...`（デフォルトアカウントで動作）。
設定ファイルと環境変数の両方が設定されている場合、設定ファイルが優先されます。

マルチアカウントサポート：アカウントごとのトークンとオプションの`name`を持つ`channels.telegram.accounts`を使用します。共有パターンについては、[`gateway/configuration`](/gateway/configuration#telegramaccounts--discordaccounts--slackaccounts--signalaccounts--imessageaccounts)を参照してください。

3) ゲートウェイを起動します。トークンが解決されると（設定ファイル優先、環境変数フォールバック）、Telegramが起動します。
4) DMアクセスはデフォルトでペアリング。ボットに初めて連絡したときにコードを承認します。
5) グループの場合：ボットを追加し、プライバシー/管理者の動作を決定し（下記）、`channels.telegram.groups`を設定してメンション制御 + 許可リストを制御します。

## トークン + プライバシー + 権限（Telegram側）

### トークンの作成（BotFather）
- `/newbot`でボットが作成され、トークンが返されます（秘密にしてください）。
- トークンが漏洩した場合、@BotFatherで取り消し/再生成し、設定を更新します。

### グループメッセージの可視性（プライバシーモード）
Telegramボットはデフォルトで**プライバシーモード**になっており、受信するグループメッセージが制限されます。
ボットが*すべて*のグループメッセージを見る必要がある場合、2つのオプションがあります：
- `/setprivacy`でプライバシーモードを無効にする **または**
- ボットをグループの**管理者**として追加する（管理者ボットはすべてのメッセージを受信します）。

**注意：** プライバシーモードを切り替えると、Telegramは変更を有効にするために各グループからボットを削除して再追加する必要があります。

### グループ権限（管理者権限）
管理者ステータスはグループ内（Telegram UI）で設定されます。管理者ボットは常にすべてのグループメッセージを受信するため、完全な可視性が必要な場合は管理者を使用してください。

## 動作方法（ビヘイビア）
- インバウンドメッセージは、返信コンテキストとメディアプレースホルダーを含む共有チャネルエンベロープに正規化されます。
- グループ返信はデフォルトでメンションが必要です（ネイティブ@メンションまたは`agents.list[].groupChat.mentionPatterns` / `messages.groupChat.mentionPatterns`）。
- マルチエージェント上書き：`agents.list[].groupChat.mentionPatterns`でエージェントごとのパターンを設定します。
- 返信は常に同じTelegramチャットにルーティングされます。
- ロングポーリングはgrammYランナーを使用し、チャットごとのシーケンシングを行います。全体の同時実行数は`agents.defaults.maxConcurrent`で制限されます。
- Telegram Bot APIは既読通知をサポートしていません。`sendReadReceipts`オプションはありません。

## フォーマット（Telegram HTML）
- アウトバウンドTelegramテキストは`parse_mode: "HTML"`を使用します（Telegramがサポートするタグのサブセット）。
- Markdownのような入力は**Telegram対応HTML**にレンダリングされます（太字/斜体/取り消し線/コード/リンク）。ブロック要素は改行/箇条書きを含むテキストに平坦化されます。
- モデルからの生のHTMLはTelegramパースエラーを避けるためにエスケープされます。
- TelegramがHTMLペイロードを拒否した場合、OpenClawは同じメッセージをプレーンテキストで再試行します。

## コマンド（ネイティブ + カスタム）
OpenClawは起動時にネイティブコマンド（`/status`、`/reset`、`/model`など）をTelegramのボットメニューに登録します。
設定を介してカスタムコマンドをメニューに追加できます：

```json5
{
  channels: {
    telegram: {
      customCommands: [
        { command: "backup", description: "Gitバックアップ" },
        { command: "generate", description: "画像を作成" }
      ]
    }
  }
}
```

## トラブルシューティング

- ログに`setMyCommands failed`が表示される場合、通常は`api.telegram.org`へのアウトバウンドHTTPS/DNSがブロックされています。
- `sendMessage`または`sendChatAction`の失敗が表示される場合、IPv6ルーティングとDNSを確認してください。

詳細なヘルプ：[チャネルトラブルシューティング](/channels/troubleshooting)。

注意：
- カスタムコマンドは**メニューエントリのみ**です。他の場所で処理しない限り、OpenClawは実装しません。
- コマンド名は正規化されます（先頭の`/`を削除、小文字化）、`a-z`、`0-9`、`_`と一致する必要があります（1〜32文字）。
- カスタムコマンドは**ネイティブコマンドを上書きできません**。競合は無視され、ログに記録されます。
- `commands.native`が無効の場合、カスタムコマンドのみが登録されます（なければクリアされます）。

## 制限
- アウトバウンドテキストは`channels.telegram.textChunkLimit`（デフォルト4000）にチャンク化されます。
- オプションの改行チャンク化：`channels.telegram.chunkMode="newline"`を設定すると、長さチャンク化の前に空白行（段落境界）で分割します。
- メディアのダウンロード/アップロードは`channels.telegram.mediaMaxMb`（デフォルト5）で制限されます。
- Telegram Bot APIリクエストは`channels.telegram.timeoutSeconds`（grammY経由でデフォルト500）後にタイムアウトします。長いハングを避けるために低く設定します。
- グループ履歴コンテキストは`channels.telegram.historyLimit`（または`channels.telegram.accounts.*.historyLimit`）を使用し、`messages.groupChat.historyLimit`にフォールバックします。無効にするには`0`を設定します（デフォルト50）。
- DM履歴は`channels.telegram.dmHistoryLimit`（ユーザーターン）で制限できます。ユーザーごとの上書き：`channels.telegram.dms["<user_id>"].historyLimit`。

## グループアクティベーションモード

デフォルトでは、ボットはグループ内のメンション（`@botname`または`agents.list[].groupChat.mentionPatterns`のパターン）にのみ応答します。この動作を変更するには：

### 設定経由（推奨）

```json5
{
  channels: {
    telegram: {
      groups: {
        "-1001234567890": { requireMention: false }  // このグループでは常に応答
      }
    }
  }
}
```

**重要：** `channels.telegram.groups`を設定すると**許可リスト**が作成されます - リストされたグループ（または`"*"`）のみが受け入れられます。
フォーラムトピックは、`channels.telegram.groups.<groupId>.topics.<topicId>`でトピックごとの上書きを追加しない限り、親グループの設定（allowFrom、requireMention、skills、prompts）を継承します。

常に応答するすべてのグループを許可するには：
```json5
{
  channels: {
    telegram: {
      groups: {
        "*": { requireMention: false }  // すべてのグループで常に応答
      }
    }
  }
}
```

すべてのグループでメンションのみを保持するには（デフォルトの動作）：
```json5
{
  channels: {
    telegram: {
      groups: {
        "*": { requireMention: true }  // またはgroupsを完全に省略
      }
    }
  }
}
```

### コマンド経由（セッションレベル）

グループで送信：
- `/activation always` - すべてのメッセージに応答
- `/activation mention` - メンションが必要（デフォルト）

**注意：** コマンドはセッション状態のみを更新します。再起動後も永続的な動作を得るには、設定を使用してください。

### グループチャットIDの取得

グループからの任意のメッセージを`@userinfobot`または`@getidsbot`に転送して、チャットID（`-1001234567890`のような負の数）を確認します。

**ヒント：** 自分のユーザーIDを取得するには、ボットにDMすると、ユーザーID（ペアリングメッセージ）が返されます。またはコマンドが有効になったら`/whoami`を使用します。

**プライバシー注意：** `@userinfobot`はサードパーティのボットです。好みに応じて、ボットをグループに追加し、メッセージを送信し、`openclaw logs --follow`を使用して`chat.id`を読むか、Bot APIの`getUpdates`を使用してください。

## 設定の書き込み
デフォルトでは、Telegramはチャネルイベントまたは`/config set|unset`によってトリガーされる設定更新を書き込むことが許可されています。

これは次の場合に発生します：
- グループがスーパーグループにアップグレードされ、Telegramが`migrate_to_chat_id`を発行する（チャットIDが変更される）。OpenClawは`channels.telegram.groups`を自動的に移行できます。
- Telegramチャットで`/config set`または`/config unset`を実行する（`commands.config: true`が必要）。

無効にするには：
```json5
{
  channels: { telegram: { configWrites: false } }
}
```

## トピック（フォーラムスーパーグループ）
Telegramフォーラムトピックはメッセージごとに`message_thread_id`を含みます。OpenClawは：
- Telegramグループセッションキーに`:topic:<threadId>`を追加するため、各トピックが分離されます。
- タイピングインジケーターを送信し、`message_thread_id`で返信するため、応答はトピック内に留まります。
- 一般トピック（スレッドID `1`）は特別です：メッセージ送信は`message_thread_id`を省略します（Telegramは拒否します）が、タイピングインジケーターには引き続き含まれます。
- ルーティング/テンプレート化のためのテンプレートコンテキストで`MessageThreadId` + `IsForum`を公開します。
- トピック固有の設定は`channels.telegram.groups.<chatId>.topics.<threadId>`で利用可能です（skills、allowlists、auto-reply、system prompts、disable）。
- トピック設定は、トピックごとに上書きされない限り、グループ設定（requireMention、allowlists、skills、prompts、enabled）を継承します。

プライベートチャットは、一部のエッジケースで`message_thread_id`を含むことがあります。OpenClawはDMセッションキーを変更しませんが、存在する場合は返信/ドラフトストリーミングにスレッドIDを使用します。

## インラインボタン

Telegramはコールバックボタンを持つインラインキーボードをサポートします。

```json5
{
  "channels": {
    "telegram": {
      "capabilities": {
        "inlineButtons": "allowlist"
      }
    }
  }
}
```

アカウントごとの設定の場合：
```json5
{
  "channels": {
    "telegram": {
      "accounts": {
        "main": {
          "capabilities": {
            "inlineButtons": "allowlist"
          }
        }
      }
    }
  }
}
```

スコープ：
- `off` — インラインボタン無効
- `dm` — DMのみ（グループターゲットはブロック）
- `group` — グループのみ（DMターゲットはブロック）
- `all` — DM + グループ
- `allowlist` — DM + グループ、ただし`allowFrom`/`groupAllowFrom`で許可された送信者のみ（制御コマンドと同じルール）

デフォルト：`allowlist`。
レガシー：`capabilities: ["inlineButtons"]` = `inlineButtons: "all"`。

### ボタンの送信

`buttons`パラメーターを持つメッセージツールを使用します：

```json5
{
  "action": "send",
  "channel": "telegram",
  "to": "123456789",
  "message": "オプションを選択してください：",
  "buttons": [
    [
      {"text": "はい", "callback_data": "yes"},
      {"text": "いいえ", "callback_data": "no"}
    ],
    [
      {"text": "キャンセル", "callback_data": "cancel"}
    ]
  ]
}
```

ユーザーがボタンをクリックすると、コールバックデータが次の形式でエージェントにメッセージとして送り返されます：
`callback_data: value`

### 設定オプション

Telegram機能は2つのレベルで設定できます（上記はオブジェクト形式。レガシー文字列配列もサポート）：

- `channels.telegram.capabilities`：上書きされない限り、すべてのTelegramアカウントに適用されるグローバルデフォルト機能設定。
- `channels.telegram.accounts.<account>.capabilities`：特定のアカウントのグローバルデフォルトを上書きするアカウントごとの機能。

すべてのTelegramボット/アカウントが同じように動作する場合は、グローバル設定を使用します。異なるボットが異なる動作を必要とする場合（例えば、1つのアカウントはDMのみを処理し、別のアカウントはグループで許可される）は、アカウントごとの設定を使用します。

## アクセス制御（DM + グループ）

### DMアクセス
- デフォルト：`channels.telegram.dmPolicy = "pairing"`。不明な送信者はペアリングコードを受信し、承認されるまでメッセージは無視されます（コードは1時間後に期限切れ）。
- 承認方法：
  - `openclaw pairing list telegram`
  - `openclaw pairing approve telegram <CODE>`
- ペアリングはTelegram DMに使用されるデフォルトのトークン交換です。詳細：[ペアリング](/start/pairing)
- `channels.telegram.allowFrom`は数値ユーザーID（推奨）または`@username`エントリを受け入れます。これはボットのユーザー名ではありません。人間の送信者のIDを使用してください。ウィザードは`@username`を受け入れ、可能な場合は数値IDに解決します。

#### TelegramユーザーIDの検索
より安全（サードパーティボットなし）：
1) ゲートウェイを起動し、ボットにDMします。
2) `openclaw logs --follow`を実行し、`from.id`を探します。

代替（公式Bot API）：
1) ボットにDMします。
2) ボットトークンで更新を取得し、`message.from.id`を読みます：
   ```bash
   curl "https://api.telegram.org/bot<bot_token>/getUpdates"
   ```

サードパーティ（プライバシーは低い）：
- `@userinfobot`または`@getidsbot`にDMし、返されたユーザーIDを使用します。

### グループアクセス

2つの独立した制御：

**1. どのグループが許可されるか**（`channels.telegram.groups`経由のグループ許可リスト）：
- `groups`設定なし = すべてのグループが許可
- `groups`設定あり = リストされたグループまたは`"*"`のみが許可
- 例：`"groups": { "-1001234567890": {}, "*": {} }`はすべてのグループを許可

**2. どの送信者が許可されるか**（`channels.telegram.groupPolicy`経由の送信者フィルタリング）：
- `"open"` = 許可されたグループのすべての送信者がメッセージ可能
- `"allowlist"` = `channels.telegram.groupAllowFrom`の送信者のみがメッセージ可能
- `"disabled"` = グループメッセージは一切受け付けない
デフォルトは`groupPolicy: "allowlist"`（`groupAllowFrom`を追加しない限りブロック）。

ほとんどのユーザーが望むもの：`groupPolicy: "allowlist"` + `groupAllowFrom` + `channels.telegram.groups`にリストされた特定のグループ

## ロングポーリング vs Webhook
- デフォルト：ロングポーリング（公開URLは不要）。
- Webhookモード：`channels.telegram.webhookUrl`を設定（オプションで`channels.telegram.webhookSecret` + `channels.telegram.webhookPath`）。
  - ローカルリスナーは`0.0.0.0:8787`にバインドし、デフォルトで`POST /telegram-webhook`を提供します。
  - 公開URLが異なる場合は、リバースプロキシを使用し、`channels.telegram.webhookUrl`を公開エンドポイントに向けます。

## 返信スレッド
Telegramはタグを介したオプションのスレッド返信をサポートします：
- `[[reply_to_current]]` -- トリガーメッセージへの返信。
- `[[reply_to:<id>]]` -- 特定のメッセージIDへの返信。

`channels.telegram.replyToMode`で制御：
- `first`（デフォルト）、`all`、`off`。

## 音声メッセージ（ボイス vs ファイル）
Telegramは**ボイスノート**（丸いバブル）と**音声ファイル**（メタデータカード）を区別します。
OpenClawは後方互換性のためデフォルトで音声ファイルを使用します。

エージェントの返信でボイスノートバブルを強制するには、返信の任意の場所にこのタグを含めます：
- `[[audio_as_voice]]` — 音声をファイルではなくボイスノートとして送信。

タグは配信されるテキストから削除されます。他のチャネルはこのタグを無視します。

メッセージツール送信の場合、ボイス対応音声`media` URLで`asVoice: true`を設定します
（メディアが存在する場合、`message`はオプション）：

```json5
{
  "action": "send",
  "channel": "telegram",
  "to": "123456789",
  "media": "https://example.com/voice.ogg",
  "asVoice": true
}
```

## ステッカー

OpenClawはTelegramステッカーの受信と送信をインテリジェントキャッシングでサポートします。

### ステッカーの受信

ユーザーがステッカーを送信すると、OpenClawはステッカータイプに基づいて処理します：

- **静的ステッカー（WEBP）：** ダウンロードされ、ビジョンを通じて処理されます。ステッカーはメッセージコンテンツで`<media:sticker>`プレースホルダーとして表示されます。
- **アニメーションステッカー（TGS）：** スキップ（Lottie形式は処理用にサポートされていません）。
- **ビデオステッカー（WEBM）：** スキップ（ビデオ形式は処理用にサポートされていません）。

ステッカー受信時に利用可能なテンプレートコンテキストフィールド：
- `Sticker` — 以下を含むオブジェクト：
  - `emoji` — ステッカーに関連付けられた絵文字
  - `setName` — ステッカーセットの名前
  - `fileId` — Telegram ファイルID（同じステッカーを送り返す）
  - `fileUniqueId` — キャッシュ検索用の安定したID
  - `cachedDescription` — 利用可能な場合のキャッシュされたビジョン説明

### ステッカーキャッシュ

ステッカーはAIのビジョン機能を通じて処理され、説明が生成されます。同じステッカーが繰り返し送信されることが多いため、OpenClawは冗長なAPI呼び出しを避けるためにこれらの説明をキャッシュします。

**仕組み：**

1. **初回遭遇：** ステッカー画像がビジョン分析のためAIに送信されます。AIが説明を生成します（例：「熱心に手を振っている漫画の猫」）。
2. **キャッシュストレージ：** 説明はステッカーのファイルID、絵文字、セット名とともに保存されます。
3. **後続の遭遇：** 同じステッカーが再び見られると、キャッシュされた説明が直接使用されます。画像はAIに送信されません。

**キャッシュの場所：** `~/.openclaw/telegram/sticker-cache.json`

**キャッシュエントリ形式：**
```json
{
  "fileId": "CAACAgIAAxkBAAI...",
  "fileUniqueId": "AgADBAADb6cxG2Y",
  "emoji": "👋",
  "setName": "CoolCats",
  "description": "熱心に手を振っている漫画の猫",
  "cachedAt": "2026-01-15T10:30:00.000Z"
}
```

**メリット：**
- 同じステッカーに対する繰り返しのビジョン呼び出しを避けることでAPIコストを削減
- キャッシュされたステッカーのレスポンス時間の高速化（ビジョン処理遅延なし）
- キャッシュされた説明に基づくステッカー検索機能を有効化

キャッシュはステッカーが受信されると自動的に入力されます。手動のキャッシュ管理は不要です。

### ステッカーの送信

エージェントは`sticker`および`sticker-search`アクションを使用してステッカーを送信および検索できます。これらはデフォルトで無効になっており、設定で有効にする必要があります：

```json5
{
  channels: {
    telegram: {
      actions: {
        sticker: true
      }
    }
  }
}
```

**ステッカーを送信：**

```json5
{
  "action": "sticker",
  "channel": "telegram",
  "to": "123456789",
  "fileId": "CAACAgIAAxkBAAI..."
}
```

パラメーター：
- `fileId`（必須） — ステッカーのTelegram ファイルID。ステッカー受信時に`Sticker.fileId`から取得するか、`sticker-search`結果から取得します。
- `replyTo`（オプション） — 返信先メッセージID。
- `threadId`（オプション） — フォーラムトピック用のメッセージスレッドID。

**ステッカーを検索：**

エージェントは、説明、絵文字、またはセット名でキャッシュされたステッカーを検索できます：

```json5
{
  "action": "sticker-search",
  "channel": "telegram",
  "query": "手を振っている猫",
  "limit": 5
}
```

キャッシュから一致するステッカーを返します：
```json5
{
  "ok": true,
  "count": 2,
  "stickers": [
    {
      "fileId": "CAACAgIAAxkBAAI...",
      "emoji": "👋",
      "description": "熱心に手を振っている漫画の猫",
      "setName": "CoolCats"
    }
  ]
}
```

検索は、説明テキスト、絵文字文字、セット名全体でファジーマッチングを使用します。

**スレッド付きの例：**

```json5
{
  "action": "sticker",
  "channel": "telegram",
  "to": "-1001234567890",
  "fileId": "CAACAgIAAxkBAAI...",
  "replyTo": 42,
  "threadId": 123
}
```

## ストリーミング（ドラフト）
Telegramは、エージェントが応答を生成している間、**ドラフトバブル**をストリーミングできます。
OpenClawはBot APIの`sendMessageDraft`（実際のメッセージではない）を使用し、最終的な返信を通常のメッセージとして送信します。

要件（Telegram Bot API 9.3+）：
- **トピックが有効なプライベートチャット**（ボットのフォーラムトピックモード）。
- 受信メッセージには`message_thread_id`が含まれている必要があります（プライベートトピックスレッド）。
- グループ/スーパーグループ/チャネルではストリーミングは無視されます。

設定：
- `channels.telegram.streamMode: "off" | "partial" | "block"`（デフォルト：`partial`）
  - `partial`：最新のストリーミングテキストでドラフトバブルを更新。
  - `block`：より大きなブロック（チャンク化）でドラフトバブルを更新。
  - `off`：ドラフトストリーミングを無効化。
- オプション（`streamMode: "block"`のみ）：
  - `channels.telegram.draftChunk: { minChars?, maxChars?, breakPreference? }`
    - デフォルト：`minChars: 200`、`maxChars: 800`、`breakPreference: "paragraph"`（`channels.telegram.textChunkLimit`にクランプ）。

注意：ドラフトストリーミングは**ブロックストリーミング**（チャネルメッセージ）とは別です。
ブロックストリーミングはデフォルトでオフで、ドラフト更新の代わりに早期Telegramメッセージが必要な場合は`channels.telegram.blockStreaming: true`が必要です。

推論ストリーム（Telegramのみ）：
- `/reasoning stream`は、返信が生成されている間、ドラフトバブルに推論をストリーミングし、推論なしで最終的な回答を送信します。
- `channels.telegram.streamMode`が`off`の場合、推論ストリームは無効です。
詳細：[ストリーミング + チャンク化](/concepts/streaming)。

## 再試行ポリシー
アウトバウンドTelegram API呼び出しは、一時的なネットワーク/429エラーで指数バックオフとジッターで再試行します。`channels.telegram.retry`で設定します。[再試行ポリシー](/concepts/retry)を参照してください。

## エージェントツール（メッセージ + リアクション）
- ツール：`sendMessage`アクション（`to`、`content`、オプションの`mediaUrl`、`replyToMessageId`、`messageThreadId`）を持つ`telegram`。
- ツール：`react`アクション（`chatId`、`messageId`、`emoji`）を持つ`telegram`。
- ツール：`deleteMessage`アクション（`chatId`、`messageId`）を持つ`telegram`。
- リアクション削除セマンティクス：[/tools/reactions](/tools/reactions)を参照。
- ツールゲート：`channels.telegram.actions.reactions`、`channels.telegram.actions.sendMessage`、`channels.telegram.actions.deleteMessage`（デフォルト：有効）、および`channels.telegram.actions.sticker`（デフォルト：無効）。

## リアクション通知

**リアクションの仕組み：**
Telegramリアクションは、メッセージペイロードのプロパティではなく、**別個の`message_reaction`イベント**として到着します。ユーザーがリアクションを追加すると、OpenClawは：

1. Telegram APIから`message_reaction`更新を受信
2. 次の形式の**システムイベント**に変換：`"Telegram reaction added: {emoji} by {user} on msg {id}"`
3. 通常のメッセージと**同じセッションキー**を使用してシステムイベントをエンキュー
4. その会話に次のメッセージが到着すると、システムイベントがドレインされ、エージェントのコンテキストに前置きされます

エージェントは、メッセージメタデータではなく、会話履歴の**システム通知**としてリアクションを見ます。

**設定：**
- `channels.telegram.reactionNotifications`：どのリアクションが通知をトリガーするかを制御
  - `"off"` — すべてのリアクションを無視
  - `"own"` — ユーザーがボットメッセージにリアクションしたときに通知（ベストエフォート。インメモリ）（デフォルト）
  - `"all"` — すべてのリアクションを通知

- `channels.telegram.reactionLevel`：エージェントのリアクション機能を制御
  - `"off"` — エージェントはメッセージにリアクションできない
  - `"ack"` — ボットは確認リアクション（処理中は👀）を送信（デフォルト）
  - `"minimal"` — エージェントは控えめにリアクション可能（ガイドライン：5〜10回の交換ごとに1回）
  - `"extensive"` — エージェントは適切な場合に自由にリアクション可能

**フォーラムグループ：** フォーラムグループのリアクションには`message_thread_id`が含まれ、`agent:main:telegram:group:{chatId}:topic:{threadId}`のようなセッションキーを使用します。これにより、同じトピック内のリアクションとメッセージが一緒に保たれます。

**設定例：**
```json5
{
  channels: {
    telegram: {
      reactionNotifications: "all",  // すべてのリアクションを見る
      reactionLevel: "minimal"        // エージェントは控えめにリアクション可能
    }
  }
}
```

**要件：**
- Telegramボットは`allowed_updates`で`message_reaction`を明示的に要求する必要があります（OpenClawによって自動的に設定）
- Webhookモードの場合、リアクションはWebhook `allowed_updates`に含まれます
- ポーリングモードの場合、リアクションは`getUpdates` `allowed_updates`に含まれます

## 配信ターゲット（CLI/cron）
- チャットID（`123456789`）またはユーザー名（`@name`）をターゲットとして使用します。
- 例：`openclaw message send --channel telegram --target 123456789 --message "こんにちは"`。

## トラブルシューティング

**ボットがグループ内の非メンションメッセージに応答しない：**
- `channels.telegram.groups.*.requireMention=false`を設定した場合、Telegramの Bot API **プライバシーモード**を無効にする必要があります。
  - BotFather：`/setprivacy` → **無効**（その後、グループからボットを削除して再追加）
- `openclaw channels status`は、設定がメンションされていないグループメッセージを期待している場合に警告を表示します。
- `openclaw channels status --probe`は、明示的な数値グループIDのメンバーシップを追加でチェックできます（ワイルドカード`"*"`ルールは監査できません）。
- クイックテスト：`/activation always`（セッションのみ。永続性には設定を使用）

**ボットがグループメッセージをまったく見ない：**
- `channels.telegram.groups`が設定されている場合、グループがリストされているか、`"*"`を使用する必要があります
- @BotFatherのプライバシー設定を確認 → 「グループプライバシー」を**オフ**にする必要があります
- ボットが実際にメンバーであることを確認（読み取りアクセスのない管理者だけではない）
- ゲートウェイログを確認：`openclaw logs --follow`（「グループメッセージをスキップ」を探す）

**ボットはメンションには応答するが`/activation always`には応答しない：**
- `/activation`コマンドはセッション状態を更新しますが、設定に永続化しません
- 永続的な動作を得るには、`requireMention: false`でグループを`channels.telegram.groups`に追加します

**`/status`などのコマンドが機能しない：**
- TelegramユーザーIDが承認されていることを確認してください（ペアリングまたは`channels.telegram.allowFrom`経由）
- コマンドは`groupPolicy: "open"`のグループでも承認が必要です

**Node 22+でロングポーリングがすぐに中止される（多くの場合、プロキシ/カスタムフェッチを使用）：**
- Node 22+は`AbortSignal`インスタンスについてより厳格です。外部シグナルは`fetch`呼び出しをすぐに中止できます。
- アボートシグナルを正規化するOpenClawビルドにアップグレードするか、アップグレードできるまでNode 20でゲートウェイを実行してください。

**ボットが起動した後、静かに応答を停止する（またはログに`HttpError: Network request ... failed`）：**
- 一部のホストは`api.telegram.org`を最初にIPv6に解決します。サーバーが機能するIPv6エグレスを持っていない場合、grammYはIPv6専用リクエストで停止する可能性があります。
- IPv6エグレスを有効にする**または**`api.telegram.org`のIPv4解決を強制することで修正します（例えば、IPv4 Aレコードを使用して`/etc/hosts`エントリを追加するか、OS DNSスタックでIPv4を優先します）、その後ゲートウェイを再起動します。
- クイックチェック：`dig +short api.telegram.org A`および`dig +short api.telegram.org AAAA`でDNSが何を返すかを確認します。

## 設定リファレンス（Telegram）
完全な設定：[設定](/gateway/configuration)

プロバイダーオプション：
- `channels.telegram.enabled`：チャネル起動の有効/無効。
- `channels.telegram.botToken`：ボットトークン（BotFather）。
- `channels.telegram.tokenFile`：ファイルパスからトークンを読み取る。
- `channels.telegram.dmPolicy`：`pairing | allowlist | open | disabled`（デフォルト：pairing）。
- `channels.telegram.allowFrom`：DM許可リスト（ID/ユーザー名）。`open`には`"*"`が必要。
- `channels.telegram.groupPolicy`：`open | allowlist | disabled`（デフォルト：allowlist）。
- `channels.telegram.groupAllowFrom`：グループ送信者許可リスト（ID/ユーザー名）。
- `channels.telegram.groups`：グループごとのデフォルト + 許可リスト（グローバルデフォルトには`"*"`を使用）。
  - `channels.telegram.groups.<id>.requireMention`：メンション制御のデフォルト。
  - `channels.telegram.groups.<id>.skills`：スキルフィルター（省略 = すべてのスキル、空 = なし）。
  - `channels.telegram.groups.<id>.allowFrom`：グループごとの送信者許可リスト上書き。
  - `channels.telegram.groups.<id>.systemPrompt`：グループの追加システムプロンプト。
  - `channels.telegram.groups.<id>.enabled`：`false`の場合、グループを無効化。
  - `channels.telegram.groups.<id>.topics.<threadId>.*`：トピックごとの上書き（グループと同じフィールド）。
  - `channels.telegram.groups.<id>.topics.<threadId>.requireMention`：トピックごとのメンション制御上書き。
- `channels.telegram.capabilities.inlineButtons`：`off | dm | group | all | allowlist`（デフォルト：allowlist）。
- `channels.telegram.accounts.<account>.capabilities.inlineButtons`：アカウントごとの上書き。
- `channels.telegram.replyToMode`：`off | first | all`（デフォルト：`first`）。
- `channels.telegram.textChunkLimit`：アウトバウンドチャンクサイズ（文字）。
- `channels.telegram.chunkMode`：`length`（デフォルト）または`newline`で、長さチャンク化の前に空白行（段落境界）で分割。
- `channels.telegram.linkPreview`：アウトバウンドメッセージのリンクプレビューを切り替え（デフォルト：true）。
- `channels.telegram.streamMode`：`off | partial | block`（ドラフトストリーミング）。
- `channels.telegram.mediaMaxMb`：インバウンド/アウトバウンドメディアキャップ（MB）。
- `channels.telegram.retry`：アウトバウンドTelegram API呼び出しの再試行ポリシー（attempts、minDelayMs、maxDelayMs、jitter）。
- `channels.telegram.network.autoSelectFamily`：Node autoSelectFamilyを上書き（true=有効、false=無効）。Happy Eyeballsタイムアウトを避けるため、Node 22ではデフォルトで無効。
- `channels.telegram.proxy`：Bot API呼び出しのプロキシURL（SOCKS/HTTP）。
- `channels.telegram.webhookUrl`：Webhookモードを有効化。
- `channels.telegram.webhookSecret`：Webhookシークレット（オプション）。
- `channels.telegram.webhookPath`：ローカルWebhookパス（デフォルト`/telegram-webhook`）。
- `channels.telegram.actions.reactions`：Telegramツールリアクションをゲート。
- `channels.telegram.actions.sendMessage`：Telegramツールメッセージ送信をゲート。
- `channels.telegram.actions.deleteMessage`：Telegramツールメッセージ削除をゲート。
- `channels.telegram.actions.sticker`：Telegramステッカーアクション — 送信と検索をゲート（デフォルト：false）。
- `channels.telegram.reactionNotifications`：`off | own | all` — どのリアクションがシステムイベントをトリガーするかを制御（デフォルト：設定されていない場合`own`）。
- `channels.telegram.reactionLevel`：`off | ack | minimal | extensive` — エージェントのリアクション機能を制御（デフォルト：設定されていない場合`minimal`）。

関連するグローバルオプション：
- `agents.list[].groupChat.mentionPatterns`（メンション制御パターン）。
- `messages.groupChat.mentionPatterns`（グローバルフォールバック）。
- `commands.native`（デフォルトは`"auto"` → Telegram/Discordでオン、Slackでオフ）、`commands.text`、`commands.useAccessGroups`（コマンドの動作）。`channels.telegram.commands.native`で上書き。
- `messages.responsePrefix`、`messages.ackReaction`、`messages.ackReactionScope`、`messages.removeAckAfterReply`。
