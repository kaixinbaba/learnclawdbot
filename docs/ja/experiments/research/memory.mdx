---
title: "ワークスペースメモリ研究"
summary: "Markdown を正規ソースとし、構造化された想起のための派生インデックスを持つオフライン優先のメモリアーキテクチャ"
---

# ワークスペースメモリ v2（オフライン）：研究ノート

**ターゲット：** Clawd スタイルのワークスペース（`agents.defaults.workspace`、デフォルト `~/.openclaw/workspace`）。ここでは "memory" は 1 日 1 つの Markdown ファイル（`memory/YYYY-MM-DD.md`）と少数の安定したファイル（例：`memory.md`、`SOUL.md`）として保存されます。

このドキュメントは、Markdown を正規の、レビュー可能な真実の情報源として保持しながら、派生インデックスを介して構造化された想起（検索、エンティティサマリ、信頼度更新）を追加するオフライン優先のメモリアーキテクチャを提案します。

## なぜ変更するのか？

現在の設定（1 日 1 ファイル）は以下に優れています：

- "追記専用" ジャーナリング
- 人間による編集
- git バックの耐久性 + 監査可能性
- 低摩擦キャプチャ（"ただ書き留める"）

弱点：

- 高リコール検索（"X について何を決定したか？"、"前回 Y を試したとき？"）
- エンティティ中心の回答（"Alice / The Castle / warelay について教えて"）を多くのファイルを再読せずに
- 意見/好みの安定性（そしてそれが変わったときの証拠）
- 時間制約（"2025 年 11 月の間に何が真実だったか？"）と競合解決

## 設計目標

- **オフライン：** ネットワークなしで動作；ラップトップ/Castle で実行可能；クラウド依存なし
- **説明可能：** 取得されたアイテムは帰属可能（ファイル + 場所）であり、推論から分離可能
- **低セレモニー：** 日々のロギングは Markdown のまま、重いスキーマ作業なし
- **インクリメンタル：** v1 は FTS のみで有用；セマンティック/ベクトルとグラフはオプションのアップグレード
- **エージェントフレンドリー：** "トークン予算内での想起" を簡単にする（小さな事実のバンドルを返す）

## ノーススターモデル（Hindsight × Letta）

融合する 2 つのピース：

### Letta/MemGPT スタイルの制御ループ

- 常にコンテキスト内に小さな "core" を保持（ペルソナ + 主要なユーザー事実）
- その他すべてはコンテキスト外で、ツールを介して取得
- メモリ書き込みは明示的なツール呼び出し（append/replace/insert）、永続化され、次のターンで再注入

### Hindsight スタイルのメモリ基盤

- 観察されたもの vs 信じられているもの vs 要約されたものを分離
- retain/recall/reflect をサポート
- 証拠とともに進化できる信頼度を持つ意見
- エンティティ認識検索 + 時間クエリ（完全なナレッジグラフなしでも）

## 提案されたアーキテクチャ（Markdown 真実の情報源 + 派生インデックス）

### 正規ストア（git フレンドリー）

`~/.openclaw/workspace` を正規の人間が読めるメモリとして保持します。

推奨されるワークスペースレイアウト：

```
~/.openclaw/workspace/
  memory.md                # 小：耐久性のある事実 + 好み（core-ish）
  memory/
    YYYY-MM-DD.md          # 日次ログ（追記；ナラティブ）
  bank/                    # "型付き" メモリページ（安定、レビュー可能）
    world.md               # 世界についての客観的事実
    experience.md          # エージェントが何をしたか（一人称）
    opinions.md            # 主観的な好み/判断 + 信頼度 + 証拠ポインター
    entities/
      Peter.md
      The-Castle.md
      warelay.md
      ...
```

注意：

- 日次ログは日次ログのまま。JSON に変える必要なし
- `bank/` ファイルはキュレーションされ、リフレクションジョブによって生成され、手動で編集可能
- `memory.md` は "small + core-ish" のまま：Clawd にすべてのセッションで見てほしいもの

### 派生ストア（マシン想起）

ワークスペース下に派生インデックスを追加（必ずしも git トラッキングされない）：

```
~/.openclaw/workspace/.memory/index.sqlite
```

サポート：

- 事実 + エンティティリンク + 意見メタデータ用の SQLite スキーマ
- 語彙想起用の SQLite FTS5（高速、小型、オフライン）
- セマンティック想起用のオプションの埋め込みテーブル（引き続きオフライン）

インデックスは常に Markdown から再構築可能。

## Retain / Recall / Reflect（操作ループ）

### Retain: 日次ログを "facts" に正規化

ここで重要な Hindsight のキーインサイト：ナラティブで自己完結型の事実を保存し、小さなスニペットではない。

`memory/YYYY-MM-DD.md` の実用的なルール：

- 1 日の終わり（または途中）に、次のような 2〜5 つの箇条書きを持つ `## Retain` セクションを追加：
  - ナラティブ（ターン間のコンテキストが保持される）
  - 自己完結型（後で単独で理解できる）
  - 型 + エンティティメンションでタグ付け

例：

```markdown
## Retain
- W @Peter: 現在マラケシュにいる（2025 年 11 月 27 日〜12 月 1 日）Andy の誕生日のため。
- B @warelay: connection.update ハンドラを try/catch でラップして Baileys WS クラッシュを修正（memory/2025-11-27.md を参照）。
- O(c=0.95) @Peter: WhatsApp では簡潔な返信（<1500 文字）を好む；長いコンテンツはファイルに。
```

最小限の解析：

- 型プレフィックス：`W`（世界）、`B`（経験/伝記）、`O`（意見）、`S`（観察/要約；通常生成される）
- エンティティ：`@Peter`、`@warelay` など（slug は `bank/entities/*.md` にマップ）
- 意見の信頼度：`O(c=0.0..1.0)` オプション

著者に考えさせたくない場合：リフレクトジョブがログの残りからこれらの箇条書きを推論できますが、明示的な `## Retain` セクションを持つことが最も簡単な "品質レバー" です。

### Recall: 派生インデックスに対するクエリ

想起は以下をサポートすべき：

- **語彙：** "正確な用語/名前/コマンドを見つける"（FTS5）
- **エンティティ：** "X について教えて"（エンティティページ + エンティティリンクされた事実）
- **時間：** "11 月 27 日頃に何が起こったか" / "先週以来"
- **意見：** "Peter は何を好むか？"（信頼度 + 証拠付き）

返却形式はエージェントフレンドリーでソースを引用すべき：

- kind（`world`|`experience`|`opinion`|`observation`）
- timestamp（ソース日、または存在する場合は抽出された時間範囲）
- entities（`["Peter","warelay"]`）
- content（ナラティブ事実）
- source（`memory/2025-11-27.md#L12` など）

### Reflect: 安定したページを生成 + 信念を更新

リフレクションはスケジュールされたジョブ（毎日または heartbeat ultrathink）で：

- 最近の事実から `bank/entities/*.md` を更新（エンティティサマリ）
- 強化/矛盾に基づいて `bank/opinions.md` の信頼度を更新
- オプションで `memory.md`（"core-ish" 耐久性のある事実）への編集を提案

意見の進化（シンプル、説明可能）：

- 各意見には以下がある：
  - ステートメント
  - 信頼度 `c ∈ [0,1]`
  - `last_updated`
  - 証拠リンク（サポート + 矛盾する事実 ID）

- 新しい事実が到着したとき：
  - エンティティオーバーラップ + 類似性で候補意見を見つける（FTS 最初、後で埋め込み）
  - 小さなデルタで信頼度を更新；大きなジャンプには強い矛盾 + 繰り返しの証拠が必要

## CLI 統合：スタンドアロン vs 深い統合

推奨：OpenClaw に深く統合するが、分離可能なコアライブラリを維持。

### なぜ OpenClaw に統合するのか？

- OpenClaw はすでに以下を知っている：
  - ワークスペースパス（`agents.defaults.workspace`）
  - セッションモデル + ハートビート
  - ロギング + トラブルシューティングパターン

- エージェント自体にツールを呼び出させたい：
  - `openclaw memory recall "…" --k 25 --since 30d`
  - `openclaw memory reflect --since 7d`

### なぜまだライブラリを分割するのか？

- gateway/runtime なしでメモリロジックをテスト可能に保つ
- 他のコンテキストから再利用（ローカルスクリプト、将来のデスクトップアプリなど）

形状：メモリツールは小さな CLI + ライブラリレイヤーとなることを意図していますが、これは探索的なものです。

## "S-Collide" / SuCo: いつ使用するか（研究）

"S-Collide" が SuCo（Subspace Collision）を指す場合：これは、サブスペースで学習/構造化された衝突を使用して強いリコール/レイテンシトレードオフを目指す ANN 検索アプローチです（論文：arXiv 2411.14754、2024）。

`~/.openclaw/workspace` への実用的な見解：

- SuCo から始めない
- SQLite FTS + （オプション）シンプルな埋め込みから始める；すぐにほとんどの UX の勝利を得られる
- 以下の場合にのみ SuCo/HNSW/ScaNN クラスのソリューションを検討：
  - コーパスが大きい（数万/数十万のチャンク）
  - ブルートフォース埋め込み検索が遅すぎる
  - リコール品質が語彙検索によって意味的にボトルネックになっている

オフラインフレンドリーな代替案（複雑さの増加順）：

1. SQLite FTS5 + メタデータフィルター（ゼロ ML）
2. 埋め込み + ブルートフォース（チャンク数が少ない場合、驚くほど効果的）
3. HNSW インデックス（一般的、堅牢；ライブラリバインディングが必要）
4. SuCo（研究グレード；埋め込み可能な堅実な実装があれば魅力的）

未解決の質問：

- あなたのマシン（ラップトップ + デスクトップ）で "パーソナルアシスタントメモリ" のための最適なオフライン埋め込みモデルは何か？
- すでに Ollama を持っている場合：ローカルモデルで埋め込む；そうでなければツールチェーンに小さな埋め込みモデルを同梱

## 最小限の有用なパイロット

最小限だが有用なバージョンが欲しい場合：

- 日次ログに `bank/` エンティティページと `## Retain` セクションを追加
- 引用付き想起（パス + 行番号）に SQLite FTS を使用
- リコール品質またはスケールが要求する場合にのみ埋め込みを追加

## 参考文献

- **Letta / MemGPT コンセプト：** "コアメモリブロック" + "アーカイブメモリ" + ツール駆動の自己編集メモリ
- **Hindsight テクニカルレポート：** "retain / recall / reflect"、4 ネットワークメモリ、ナラティブ事実抽出、意見信頼度進化
- **SuCo：** arXiv 2411.14754（2024）："Subspace Collision" 近似最近傍検索
